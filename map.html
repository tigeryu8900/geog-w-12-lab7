<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>leaflet</title>
  <script>
    (function () {
      // If window.HTMLWidgets is already defined, then use it; otherwise create a
      // new object. This allows preceding code to set options that affect the
      // initialization process (though none currently exist).
      window.HTMLWidgets = window.HTMLWidgets || {};

      // See if we're running in a viewer pane. If not, we're in a web browser.
      var viewerMode = window.HTMLWidgets.viewerMode =
          /\bviewer_pane=1\b/.test(window.location);

      // See if we're running in Shiny mode. If not, it's a static document.
      // Note that static widgets can appear in both Shiny and static modes, but
      // obviously, Shiny widgets can only appear in Shiny apps/documents.
      var shinyMode = window.HTMLWidgets.shinyMode =
          typeof (window.Shiny) !== "undefined" && !!window.Shiny.outputBindings;

      // We can't count on jQuery being available, so we implement our own
      // version if necessary.
      function querySelectorAll(scope, selector) {
        if (typeof (jQuery) !== "undefined" && scope instanceof jQuery) {
          return scope.find(selector);
        }
        if (scope.querySelectorAll) {
          return scope.querySelectorAll(selector);
        }
      }

      function asArray(value) {
        if (value === null) {
          return [];
        }
        if ($.isArray(value)) {
          return value;
        }
        return [value];
      }

      // Implement jQuery's extend
      function extend(target /*, ... */) {
        if (arguments.length == 1) {
          return target;
        }
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var prop in source) {
            if (source.hasOwnProperty(prop)) {
              target[prop] = source[prop];
            }
          }
        }
        return target;
      }

      // IE8 doesn't support Array.forEach.
      function forEach(values, callback, thisArg) {
        if (values.forEach) {
          values.forEach(callback, thisArg);
        } else {
          for (var i = 0; i < values.length; i++) {
            callback.call(thisArg, values[i], i, values);
          }
        }
      }

      // Replaces the specified method with the return value of funcSource.
      //
      // Note that funcSource should not BE the new method, it should be a function
      // that RETURNS the new method. funcSource receives a single argument that is
      // the overridden method, it can be called from the new method. The overridden
      // method can be called like a regular function, it has the target permanently
      // bound to it so "this" will work correctly.
      function overrideMethod(target, methodName, funcSource) {
        var superFunc = target[methodName] || function () {
        };
        var superFuncBound = function () {
          return superFunc.apply(target, arguments);
        };
        target[methodName] = funcSource(superFuncBound);
      }

      // Add a method to delegator that, when invoked, calls
      // delegatee.methodName. If there is no such method on
      // the delegatee, but there was one on delegator before
      // delegateMethod was called, then the original version
      // is invoked instead.
      // For example:
      //
      // var a = {
      //   method1: function() { console.log('a1'); }
      //   method2: function() { console.log('a2'); }
      // };
      // var b = {
      //   method1: function() { console.log('b1'); }
      // };
      // delegateMethod(a, b, "method1");
      // delegateMethod(a, b, "method2");
      // a.method1();
      // a.method2();
      //
      // The output would be "b1", "a2".
      function delegateMethod(delegator, delegatee, methodName) {
        var inherited = delegator[methodName];
        delegator[methodName] = function () {
          var target = delegatee;
          var method = delegatee[methodName];

          // The method doesn't exist on the delegatee. Instead,
          // call the method on the delegator, if it exists.
          if (!method) {
            target = delegator;
            method = inherited;
          }

          if (method) {
            return method.apply(target, arguments);
          }
        };
      }

      // Implement a vague facsimilie of jQuery's data method
      function elementData(el, name, value) {
        if (arguments.length == 2) {
          return el["htmlwidget_data_" + name];
        } else if (arguments.length == 3) {
          el["htmlwidget_data_" + name] = value;
          return el;
        } else {
          throw new Error("Wrong number of arguments for elementData: " +
              arguments.length);
        }
      }

      // http://stackoverflow.com/questions/3446170/escape-string-for-use-in-javascript-regex
      function escapeRegExp(str) {
        return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
      }

      function hasClass(el, className) {
        var re = new RegExp("\\b" + escapeRegExp(className) + "\\b");
        return re.test(el.className);
      }

      // elements - array (or array-like object) of HTML elements
      // className - class name to test for
      // include - if true, only return elements with given className;
      //   if false, only return elements *without* given className
      function filterByClass(elements, className, include) {
        var results = [];
        for (var i = 0; i < elements.length; i++) {
          if (hasClass(elements[i], className) == include) {
            results.push(elements[i]);
          }
        }
        return results;
      }

      function on(obj, eventName, func) {
        if (obj.addEventListener) {
          obj.addEventListener(eventName, func, false);
        } else if (obj.attachEvent) {
          obj.attachEvent(eventName, func);
        }
      }

      function off(obj, eventName, func) {
        if (obj.removeEventListener) {
          obj.removeEventListener(eventName, func, false);
        } else if (obj.detachEvent) {
          obj.detachEvent(eventName, func);
        }
      }

      // Translate array of values to top/right/bottom/left, as usual with
      // the "padding" CSS property
      // https://developer.mozilla.org/en-US/docs/Web/CSS/padding
      function unpackPadding(value) {
        if (typeof (value) === "number") {
          value = [value];
        }
        if (value.length === 1) {
          return {top: value[0], right: value[0], bottom: value[0], left: value[0]};
        }
        if (value.length === 2) {
          return {top: value[0], right: value[1], bottom: value[0], left: value[1]};
        }
        if (value.length === 3) {
          return {top: value[0], right: value[1], bottom: value[2], left: value[1]};
        }
        if (value.length === 4) {
          return {top: value[0], right: value[1], bottom: value[2], left: value[3]};
        }
      }

      // Convert an unpacked padding object to a CSS value
      function paddingToCss(paddingObj) {
        return paddingObj.top + "px " + paddingObj.right + "px " + paddingObj.bottom + "px "
            + paddingObj.left + "px";
      }

      // Makes a number suitable for CSS
      function px(x) {
        if (typeof (x) === "number") {
          return x + "px";
        } else {
          return x;
        }
      }

      // Retrieves runtime widget sizing information for an element.
      // The return value is either null, or an object with fill, padding,
      // defaultWidth, defaultHeight fields.
      function sizingPolicy(el) {
        var sizingEl = document.querySelector(
            "script[data-for='" + el.id + "'][type='application/htmlwidget-sizing']");
        if (!sizingEl) {
          return null;
        }
        var sp = JSON.parse(sizingEl.textContent || sizingEl.text || "{}");
        if (viewerMode) {
          return sp.viewer;
        } else {
          return sp.browser;
        }
      }

      // @param tasks Array of strings (or falsy value, in which case no-op).
      //   Each element must be a valid JavaScript expression that yields a
      //   function. Or, can be an array of objects with "code" and "data"
      //   properties; in this case, the "code" property should be a string
      //   of JS that's an expr that yields a function, and "data" should be
      //   an object that will be added as an additional argument when that
      //   function is called.
      // @param target The object that will be "this" for each function
      //   execution.
      // @param args Array of arguments to be passed to the functions. (The
      //   same arguments will be passed to all functions.)
      function evalAndRun(tasks, target, args) {
        if (tasks) {
          forEach(tasks, function (task) {
            var theseArgs = args;
            if (typeof (task) === "object") {
              theseArgs = theseArgs.concat([task.data]);
              task = task.code;
            }
            var taskFunc = tryEval(task);
            if (typeof (taskFunc) !== "function") {
              throw new Error("Task must be a function! Source:\n" + task);
            }
            taskFunc.apply(target, theseArgs);
          });
        }
      }

      // Attempt eval() both with and without enclosing in parentheses.
      // Note that enclosing coerces a function declaration into
      // an expression that eval() can parse
      // (otherwise, a SyntaxError is thrown)
      function tryEval(code) {
        var result = null;
        try {
          result = eval("(" + code + ")");
        } catch (error) {
          if (!(error instanceof SyntaxError)) {
            throw error;
          }
          try {
            result = eval(code);
          } catch (e) {
            if (e instanceof SyntaxError) {
              throw error;
            } else {
              throw e;
            }
          }
        }
        return result;
      }

      function initSizing(el) {
        var sizing = sizingPolicy(el);
        if (!sizing) {
          return;
        }

        var cel = document.getElementById("htmlwidget_container");
        if (!cel) {
          return;
        }

        if (typeof (sizing.padding) !== "undefined") {
          document.body.style.margin = "0";
          document.body.style.padding = paddingToCss(unpackPadding(sizing.padding));
        }

        if (sizing.fill) {
          document.body.style.overflow = "hidden";
          document.body.style.width = "100%";
          document.body.style.height = "100%";
          document.documentElement.style.width = "100%";
          document.documentElement.style.height = "100%";
          if (cel) {
            cel.style.position = "absolute";
            var pad = unpackPadding(sizing.padding);
            cel.style.top = pad.top + "px";
            cel.style.right = pad.right + "px";
            cel.style.bottom = pad.bottom + "px";
            cel.style.left = pad.left + "px";
            el.style.width = "100%";
            el.style.height = "100%";
          }

          return {
            getWidth: function () {
              return cel.offsetWidth;
            },
            getHeight: function () {
              return cel.offsetHeight;
            }
          };

        } else {
          el.style.width = px(sizing.width);
          el.style.height = px(sizing.height);

          return {
            getWidth: function () {
              return el.offsetWidth;
            },
            getHeight: function () {
              return el.offsetHeight;
            }
          };
        }
      }

      // Default implementations for methods
      var defaults = {
        find: function (scope) {
          return querySelectorAll(scope, "." + this.name);
        },
        renderError: function (el, err) {
          var $el = $(el);

          this.clearError(el);

          // Add all these error classes, as Shiny does
          var errClass = "shiny-output-error";
          if (err.type !== null) {
            // use the classes of the error condition as CSS class names
            errClass = errClass + " " + $.map(asArray(err.type), function (type) {
              return errClass + "-" + type;
            }).join(" ");
          }
          errClass = errClass + " htmlwidgets-error";

          // Is el inline or block? If inline or inline-block, just display:none it
          // and add an inline error.
          var display = $el.css("display");
          $el.data("restore-display-mode", display);

          if (display === "inline" || display === "inline-block") {
            $el.hide();
            if (err.message !== "") {
              var errorSpan = $("<span>").addClass(errClass);
              errorSpan.text(err.message);
              $el.after(errorSpan);
            }
          } else if (display === "block") {
            // If block, add an error just after the el, set visibility:none on the
            // el, and position the error to be on top of the el.
            // Mark it with a unique ID and CSS class so we can remove it later.
            $el.css("visibility", "hidden");
            if (err.message !== "") {
              var errorDiv = $("<div>").addClass(errClass).css("position", "absolute")
              .css("top", el.offsetTop)
              .css("left", el.offsetLeft)
              // setting width can push out the page size, forcing otherwise
              // unnecessary scrollbars to appear and making it impossible for
              // the element to shrink; so use max-width instead
              .css("maxWidth", el.offsetWidth)
              .css("height", el.offsetHeight);
              errorDiv.text(err.message);
              $el.after(errorDiv);

              // Really dumb way to keep the size/position of the error in sync with
              // the parent element as the window is resized or whatever.
              var intId = setInterval(function () {
                if (!errorDiv[0].parentElement) {
                  clearInterval(intId);
                  return;
                }
                errorDiv
                .css("top", el.offsetTop)
                .css("left", el.offsetLeft)
                .css("maxWidth", el.offsetWidth)
                .css("height", el.offsetHeight);
              }, 500);
            }
          }
        },
        clearError: function (el) {
          var $el = $(el);
          var display = $el.data("restore-display-mode");
          $el.data("restore-display-mode", null);

          if (display === "inline" || display === "inline-block") {
            if (display) {
              $el.css("display", display);
            }
            $(el.nextSibling).filter(".htmlwidgets-error").remove();
          } else if (display === "block") {
            $el.css("visibility", "inherit");
            $(el.nextSibling).filter(".htmlwidgets-error").remove();
          }
        },
        sizing: {}
      };

      // Called by widget bindings to register a new type of widget. The definition
      // object can contain the following properties:
      // - name (required) - A string indicating the binding name, which will be
      //   used by default as the CSS classname to look for.
      // - initialize (optional) - A function(el) that will be called once per
      //   widget element; if a value is returned, it will be passed as the third
      //   value to renderValue.
      // - renderValue (required) - A function(el, data, initValue) that will be
      //   called with data. Static contexts will cause this to be called once per
      //   element; Shiny apps will cause this to be called multiple times per
      //   element, as the data changes.
      window.HTMLWidgets.widget = function (definition) {
        if (!definition.name) {
          throw new Error("Widget must have a name");
        }
        if (!definition.type) {
          throw new Error("Widget must have a type");
        }
        // Currently we only support output widgets
        if (definition.type !== "output") {
          throw new Error("Unrecognized widget type '" + definition.type + "'");
        }
        // TODO: Verify that .name is a valid CSS classname

        // Support new-style instance-bound definitions. Old-style class-bound
        // definitions have one widget "object" per widget per type/class of
        // widget; the renderValue and resize methods on such widget objects
        // take el and instance arguments, because the widget object can't
        // store them. New-style instance-bound definitions have one widget
        // object per widget instance; the definition that's passed in doesn't
        // provide renderValue or resize methods at all, just the single method
        //   factory(el, width, height)
        // which returns an object that has renderValue(x) and resize(w, h).
        // This enables a far more natural programming style for the widget
        // author, who can store per-instance state using either OO-style
        // instance fields or functional-style closure variables (I guess this
        // is in contrast to what can only be called C-style pseudo-OO which is
        // what we required before).
        if (definition.factory) {
          definition = createLegacyDefinitionAdapter(definition);
        }

        if (!definition.renderValue) {
          throw new Error("Widget must have a renderValue function");
        }

        // For static rendering (non-Shiny), use a simple widget registration
        // scheme. We also use this scheme for Shiny apps/documents that also
        // contain static widgets.
        window.HTMLWidgets.widgets = window.HTMLWidgets.widgets || [];
        // Merge defaults into the definition; don't mutate the original definition.
        var staticBinding = extend({}, defaults, definition);
        overrideMethod(staticBinding, "find", function (superfunc) {
          return function (scope) {
            var results = superfunc(scope);
            // Filter out Shiny outputs, we only want the static kind
            return filterByClass(results, "html-widget-output", false);
          };
        });
        window.HTMLWidgets.widgets.push(staticBinding);

        if (shinyMode) {
          // Shiny is running. Register the definition with an output binding.
          // The definition itself will not be the output binding, instead
          // we will make an output binding object that delegates to the
          // definition. This is because we foolishly used the same method
          // name (renderValue) for htmlwidgets definition and Shiny bindings
          // but they actually have quite different semantics (the Shiny
          // bindings receive data that includes lots of metadata that it
          // strips off before calling htmlwidgets renderValue). We can't
          // just ignore the difference because in some widgets it's helpful
          // to call this.renderValue() from inside of resize(), and if
          // we're not delegating, then that call will go to the Shiny
          // version instead of the htmlwidgets version.

          // Merge defaults with definition, without mutating either.
          var bindingDef = extend({}, defaults, definition);

          // This object will be our actual Shiny binding.
          var shinyBinding = new Shiny.OutputBinding();

          // With a few exceptions, we'll want to simply use the bindingDef's
          // version of methods if they are available, otherwise fall back to
          // Shiny's defaults. NOTE: If Shiny's output bindings gain additional
          // methods in the future, and we want them to be overrideable by
          // HTMLWidget binding definitions, then we'll need to add them to this
          // list.
          delegateMethod(shinyBinding, bindingDef, "getId");
          delegateMethod(shinyBinding, bindingDef, "onValueChange");
          delegateMethod(shinyBinding, bindingDef, "onValueError");
          delegateMethod(shinyBinding, bindingDef, "renderError");
          delegateMethod(shinyBinding, bindingDef, "clearError");
          delegateMethod(shinyBinding, bindingDef, "showProgress");

          // The find, renderValue, and resize are handled differently, because we
          // want to actually decorate the behavior of the bindingDef methods.

          shinyBinding.find = function (scope) {
            var results = bindingDef.find(scope);

            // Only return elements that are Shiny outputs, not static ones
            var dynamicResults = results.filter(".html-widget-output");

            // It's possible that whatever caused Shiny to think there might be
            // new dynamic outputs, also caused there to be new static outputs.
            // Since there might be lots of different htmlwidgets bindings, we
            // schedule execution for later--no need to staticRender multiple
            // times.
            if (results.length !== dynamicResults.length) {
              scheduleStaticRender();
            }

            return dynamicResults;
          };

          // Wrap renderValue to handle initialization, which unfortunately isn't
          // supported natively by Shiny at the time of this writing.

          shinyBinding.renderValue = function (el, data) {
            Shiny.renderDependencies(data.deps);
            // Resolve strings marked as javascript literals to objects
            if (!(data.evals instanceof Array)) {
              data.evals = [data.evals];
            }
            for (var i = 0; data.evals && i < data.evals.length; i++) {
              window.HTMLWidgets.evaluateStringMember(data.x, data.evals[i]);
            }
            if (!bindingDef.renderOnNullValue) {
              if (data.x === null) {
                el.style.visibility = "hidden";
                return;
              } else {
                el.style.visibility = "inherit";
              }
            }
            if (!elementData(el, "initialized")) {
              initSizing(el);

              elementData(el, "initialized", true);
              if (bindingDef.initialize) {
                var result = bindingDef.initialize(el, el.offsetWidth,
                    el.offsetHeight);
                elementData(el, "init_result", result);
              }
            }
            bindingDef.renderValue(el, data.x, elementData(el, "init_result"));
            evalAndRun(data.jsHooks.render, elementData(el, "init_result"), [el, data.x]);
          };

          // Only override resize if bindingDef implements it
          if (bindingDef.resize) {
            shinyBinding.resize = function (el, width, height) {
              // Shiny can call resize before initialize/renderValue have been
              // called, which doesn't make sense for widgets.
              if (elementData(el, "initialized")) {
                bindingDef.resize(el, width, height, elementData(el, "init_result"));
              }
            };
          }

          Shiny.outputBindings.register(shinyBinding, bindingDef.name);
        }
      };

      var scheduleStaticRenderTimerId = null;

      function scheduleStaticRender() {
        if (!scheduleStaticRenderTimerId) {
          scheduleStaticRenderTimerId = setTimeout(function () {
            scheduleStaticRenderTimerId = null;
            window.HTMLWidgets.staticRender();
          }, 1);
        }
      }

      // Render static widgets after the document finishes loading
      // Statically render all elements that are of this widget's class
      window.HTMLWidgets.staticRender = function () {
        var bindings = window.HTMLWidgets.widgets || [];
        forEach(bindings, function (binding) {
          var matches = binding.find(document.documentElement);
          forEach(matches, function (el) {
            var sizeObj = initSizing(el, binding);

            if (hasClass(el, "html-widget-static-bound")) {
              return;
            }
            el.className = el.className + " html-widget-static-bound";

            var initResult;
            if (binding.initialize) {
              initResult = binding.initialize(el,
                  sizeObj ? sizeObj.getWidth() : el.offsetWidth,
                  sizeObj ? sizeObj.getHeight() : el.offsetHeight
              );
              elementData(el, "init_result", initResult);
            }

            if (binding.resize) {
              var lastSize = {
                w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
                h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
              };
              var resizeHandler = function (e) {
                var size = {
                  w: sizeObj ? sizeObj.getWidth() : el.offsetWidth,
                  h: sizeObj ? sizeObj.getHeight() : el.offsetHeight
                };
                if (size.w === 0 && size.h === 0) {
                  return;
                }
                if (size.w === lastSize.w && size.h === lastSize.h) {
                  return;
                }
                lastSize = size;
                binding.resize(el, size.w, size.h, initResult);
              };

              on(window, "resize", resizeHandler);

              // This is needed for cases where we're running in a Shiny
              // app, but the widget itself is not a Shiny output, but
              // rather a simple static widget. One example of this is
              // an rmarkdown document that has runtime:shiny and widget
              // that isn't in a render function. Shiny only knows to
              // call resize handlers for Shiny outputs, not for static
              // widgets, so we do it ourselves.
              if (window.jQuery) {
                window.jQuery(document).on(
                    "shown.htmlwidgets shown.bs.tab.htmlwidgets shown.bs.collapse.htmlwidgets",
                    resizeHandler
                );
                window.jQuery(document).on(
                    "hidden.htmlwidgets hidden.bs.tab.htmlwidgets hidden.bs.collapse.htmlwidgets",
                    resizeHandler
                );
              }

              // This is needed for the specific case of ioslides, which
              // flips slides between display:none and display:block.
              // Ideally we would not have to have ioslide-specific code
              // here, but rather have ioslides raise a generic event,
              // but the rmarkdown package just went to CRAN so the
              // window to getting that fixed may be long.
              if (window.addEventListener) {
                // It's OK to limit this to window.addEventListener
                // browsers because ioslides itself only supports
                // such browsers.
                on(document, "slideenter", resizeHandler);
                on(document, "slideleave", resizeHandler);
              }
            }

            var scriptData = document.querySelector(
                "script[data-for='" + el.id + "'][type='application/json']");
            if (scriptData) {
              var data = JSON.parse(scriptData.textContent || scriptData.text);
              // Resolve strings marked as javascript literals to objects
              if (!(data.evals instanceof Array)) {
                data.evals = [data.evals];
              }
              for (var k = 0; data.evals && k < data.evals.length; k++) {
                window.HTMLWidgets.evaluateStringMember(data.x, data.evals[k]);
              }
              binding.renderValue(el, data.x, initResult);
              evalAndRun(data.jsHooks.render, initResult, [el, data.x]);
            }
          });
        });

        invokePostRenderHandlers();
      }

      function has_jQuery3() {
        if (!window.jQuery) {
          return false;
        }
        var $version = window.jQuery.fn.jquery;
        var $major_version = parseInt($version.split(".")[0]);
        return $major_version >= 3;
      }

      /*
    / Shiny 1.4 bumped jQuery from 1.x to 3.x which means jQuery's
    / on-ready handler (i.e., $(fn)) is now asyncronous (i.e., it now
    / really means $(setTimeout(fn)).
    / https://jquery.com/upgrade-guide/3.0/#breaking-change-document-ready-handlers-are-now-asynchronous
    /
    / Since Shiny uses $() to schedule initShiny, shiny>=1.4 calls initShiny
    / one tick later than it did before, which means staticRender() is
    / called renderValue() earlier than (advanced) widget authors might be expecting.
    / https://github.com/rstudio/shiny/issues/2630
    /
    / For a concrete example, leaflet has some methods (e.g., updateBounds)
    / which reference Shiny methods registered in initShiny (e.g., setInputValue).
    / Since leaflet is privy to this life-cycle, it knows to use setTimeout() to
    / delay execution of those methods (until Shiny methods are ready)
    / https://github.com/rstudio/leaflet/blob/18ec981/javascript/src/index.js#L266-L268
    /
    / Ideally widget authors wouldn't need to use this setTimeout() hack that
    / leaflet uses to call Shiny methods on a staticRender(). In the long run,
    / the logic initShiny should be broken up so that method registration happens
    / right away, but binding happens later.
    */
      function maybeStaticRenderLater() {
        if (shinyMode && has_jQuery3()) {
          window.jQuery(window.HTMLWidgets.staticRender);
        } else {
          window.HTMLWidgets.staticRender();
        }
      }

      if (document.addEventListener) {
        document.addEventListener("DOMContentLoaded", function () {
          document.removeEventListener("DOMContentLoaded", arguments.callee, false);
          maybeStaticRenderLater();
        }, false);
      } else if (document.attachEvent) {
        document.attachEvent("onreadystatechange", function () {
          if (document.readyState === "complete") {
            document.detachEvent("onreadystatechange", arguments.callee);
            maybeStaticRenderLater();
          }
        });
      }

      window.HTMLWidgets.getAttachmentUrl = function (depname, key) {
        // If no key, default to the first item
        if (typeof (key) === "undefined") {
          key = 1;
        }

        var link = document.getElementById(depname + "-" + key + "-attachment");
        if (!link) {
          throw new Error("Attachment " + depname + "/" + key + " not found in document");
        }
        return link.getAttribute("href");
      };

      window.HTMLWidgets.dataframeToD3 = function (df) {
        var names = [];
        var length;
        for (var name in df) {
          if (df.hasOwnProperty(name)) {
            names.push(name);
          }
          if (typeof (df[name]) !== "object" || typeof (df[name].length) === "undefined") {
            throw new Error("All fields must be arrays");
          } else if (typeof (length) !== "undefined" && length !== df[name].length) {
            throw new Error("All fields must be arrays of the same length");
          }
          length = df[name].length;
        }
        var results = [];
        var item;
        for (var row = 0; row < length; row++) {
          item = {};
          for (var col = 0; col < names.length; col++) {
            item[names[col]] = df[names[col]][row];
          }
          results.push(item);
        }
        return results;
      };

      window.HTMLWidgets.transposeArray2D = function (array) {
        if (array.length === 0) {
          return array;
        }
        var newArray = array[0].map(function (col, i) {
          return array.map(function (row) {
            return row[i]
          })
        });
        return newArray;
      };
      // Split value at splitChar, but allow splitChar to be escaped
      // using escapeChar. Any other characters escaped by escapeChar
      // will be included as usual (including escapeChar itself).
      function splitWithEscape(value, splitChar, escapeChar) {
        var results = [];
        var escapeMode = false;
        var currentResult = "";
        for (var pos = 0; pos < value.length; pos++) {
          if (!escapeMode) {
            if (value[pos] === splitChar) {
              results.push(currentResult);
              currentResult = "";
            } else if (value[pos] === escapeChar) {
              escapeMode = true;
            } else {
              currentResult += value[pos];
            }
          } else {
            currentResult += value[pos];
            escapeMode = false;
          }
        }
        if (currentResult !== "") {
          results.push(currentResult);
        }
        return results;
      }

      // Function authored by Yihui/JJ Allaire
      window.HTMLWidgets.evaluateStringMember = function (o, member) {
        var parts = splitWithEscape(member, '.', '\\');
        for (var i = 0, l = parts.length; i < l; i++) {
          var part = parts[i];
          // part may be a character or 'numeric' member name
          if (o !== null && typeof o === "object" && part in o) {
            if (i == (l - 1)) { // if we are at the end of the line then evalulate
              if (typeof o[part] === "string") {
                o[part] = tryEval(o[part]);
              }
            } else { // otherwise continue to next embedded object
              o = o[part];
            }
          }
        }
      };

      // Retrieve the HTMLWidget instance (i.e. the return value of an
      // HTMLWidget binding's initialize() or factory() function)
      // associated with an element, or null if none.
      window.HTMLWidgets.getInstance = function (el) {
        return elementData(el, "init_result");
      };

      // Finds the first element in the scope that matches the selector,
      // and returns the HTMLWidget instance (i.e. the return value of
      // an HTMLWidget binding's initialize() or factory() function)
      // associated with that element, if any. If no element matches the
      // selector, or the first matching element has no HTMLWidget
      // instance associated with it, then null is returned.
      //
      // The scope argument is optional, and defaults to window.document.
      window.HTMLWidgets.find = function (scope, selector) {
        if (arguments.length == 1) {
          selector = scope;
          scope = document;
        }

        var el = scope.querySelector(selector);
        if (el === null) {
          return null;
        } else {
          return window.HTMLWidgets.getInstance(el);
        }
      };

      // Finds all elements in the scope that match the selector, and
      // returns the HTMLWidget instances (i.e. the return values of
      // an HTMLWidget binding's initialize() or factory() function)
      // associated with the elements, in an array. If elements that
      // match the selector don't have an associated HTMLWidget
      // instance, the returned array will contain nulls.
      //
      // The scope argument is optional, and defaults to window.document.
      window.HTMLWidgets.findAll = function (scope, selector) {
        if (arguments.length == 1) {
          selector = scope;
          scope = document;
        }

        var nodes = scope.querySelectorAll(selector);
        var results = [];
        for (var i = 0; i < nodes.length; i++) {
          results.push(window.HTMLWidgets.getInstance(nodes[i]));
        }
        return results;
      };

      var postRenderHandlers = [];

      function invokePostRenderHandlers() {
        while (postRenderHandlers.length) {
          var handler = postRenderHandlers.shift();
          if (handler) {
            handler();
          }
        }
      }

      // Register the given callback function to be invoked after the
      // next time static widgets are rendered.
      window.HTMLWidgets.addPostRenderHandler = function (callback) {
        postRenderHandlers.push(callback);
      };

      // Takes a new-style instance-bound definition, and returns an
      // old-style class-bound definition. This saves us from having
      // to rewrite all the logic in this file to accomodate both
      // types of definitions.
      function createLegacyDefinitionAdapter(defn) {
        var result = {
          name: defn.name,
          type: defn.type,
          initialize: function (el, width, height) {
            return defn.factory(el, width, height);
          },
          renderValue: function (el, x, instance) {
            return instance.renderValue(x);
          },
          resize: function (el, width, height, instance) {
            return instance.resize(width, height);
          }
        };

        if (defn.find) {
          result.find = defn.find;
        }
        if (defn.renderError) {
          result.renderError = defn.renderError;
        }
        if (defn.clearError) {
          result.clearError = defn.clearError;
        }

        return result;
      }
    })();
  </script>
  ¶
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.1/dist/jquery.min.js"></script>
  ¶
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css"
        integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI="
        crossorigin=""/>
  ¶
  <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"
          integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM="
          crossorigin=""></script>
  ¶
  <style>
    img.leaflet-tile {
      padding: 0;
      margin: 0;
      border-radius: 0;
      border: none;
    }

    .info {
      padding: 6px 8px;
      font: 14px/16px Arial, Helvetica, sans-serif;
      background: white;
      background: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
      border-radius: 5px;
    }

    .legend {
      line-height: 18px;
      color: #555;
    }

    .legend svg text {
      fill: #555;
    }

    .legend svg line {
      stroke: #555;
    }

    .legend i {
      width: 18px;
      height: 18px;
      margin-right: 4px;
      opacity: 0.7;
      display: inline-block;
      vertical-align: top;

      zoom: 1;
      *display: inline;
    }
  </style>
  ¶
  <script>
    !function (t, s) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = s()
          : "function"
          == typeof define && define.amd ? define(s) : t.proj4 = s()
    }(this, function () {
      "use strict";

      function k(t, s) {
        if (t[s]) {
          return t[s];
        }
        for (var i, a = Object.keys(t), h = s.toLowerCase().replace(H, ""), e = -1;
            ++e < a.length;) {
          if ((i = a[e]).toLowerCase().replace(H, "") === h) {
            return t[i]
          }
        }
      }

      function e(t) {
        if ("string" != typeof t) {
          throw new Error("not a string");
        }
        this.text = t.trim(), this.level = 0, this.place = 0, this.root = null, this.stack = [], this.currentObject = null, this.state = K
      }

      function h(t, s, i) {
        Array.isArray(s) && (i.unshift(s), s = null);
        var a = s ? {} : t, h = i.reduce(function (t, s) {
          return n(s, t), t
        }, a);
        s && (t[s] = h)
      }

      function n(t, s) {
        if (Array.isArray(t)) {
          var i, a = t.shift();
          if ("PARAMETER" === a && (a = t.shift()), 1 === t.length) {
            return Array.isArray(t[0])
                ? (s[a] = {}, void n(t[0], s[a])) : void (s[a] = t[0]);
          }
          if (t.length) {
            if ("TOWGS84" !== a) {
              if ("AXIS" === a) {
                return a in s || (s[a] = []), void s[a].push(t);
              }
              switch (Array.isArray(a) || (s[a] = {}), a) {
                case"UNIT":
                case"PRIMEM":
                case"VERT_DATUM":
                  return s[a] = {
                    name: t[0].toLowerCase(),
                    convert: t[1]
                  }, void (3 === t.length && n(t[2], s[a]));
                case"SPHEROID":
                case"ELLIPSOID":
                  return s[a] = {name: t[0], a: t[1], rf: t[2]}, void (4 === t.length
                      && n(t[3], s[a]));
                case"PROJECTEDCRS":
                case"PROJCRS":
                case"GEOGCS":
                case"GEOCCS":
                case"PROJCS":
                case"LOCAL_CS":
                case"GEODCRS":
                case"GEODETICCRS":
                case"GEODETICDATUM":
                case"EDATUM":
                case"ENGINEERINGDATUM":
                case"VERT_CS":
                case"VERTCRS":
                case"VERTICALCRS":
                case"COMPD_CS":
                case"COMPOUNDCRS":
                case"ENGINEERINGCRS":
                case"ENGCRS":
                case"FITTED_CS":
                case"LOCAL_DATUM":
                case"DATUM":
                  return t[0] = ["name", t[0]], void h(s, a, t);
                default:
                  for (i = -1; ++i < t.length;) {
                    if (!Array.isArray(t[i])) {
                      return n(t,
                          s[a]);
                    }
                  }
                  return h(s, a, t)
              }
            } else {
              s[a] = t;
            }
          } else {
            s[a] = !0
          }
        } else {
          s[t] = !0
        }
      }

      function r(t) {
        return t * it
      }

      function o(e) {
        function t(t) {
          return t * (e.to_meter || 1)
        }

        if ("GEOGCS" === e.type ? e.projName = "longlat" : "LOCAL_CS" === e.type
            ? (e.projName = "identity", e.local = !0) : "object" == typeof e.PROJECTION
                ? e.projName = Object.keys(e.PROJECTION)[0]
                : e.projName = e.PROJECTION, e.AXIS) {
          for (var s = "", i = 0, a = e.AXIS.length; i < a; ++i) {
            var h = e.AXIS[i][0].toLowerCase();
            -1 !== h.indexOf("north") ? s += "n" : -1 !== h.indexOf("south") ? s += "s" : -1
            !== h.indexOf("east") ? s += "e" : -1 !== h.indexOf("west") && (s += "w")
          }
          2 === s.length && (s += "u"), 3 === s.length && (e.axis = s)
        }
        e.UNIT && (e.units = e.UNIT.name.toLowerCase(), "metre" === e.units
        && (e.units = "meter"), e.UNIT.convert && ("GEOGCS" === e.type ? e.DATUM
            && e.DATUM.SPHEROID
            && (e.to_meter = e.UNIT.convert * e.DATUM.SPHEROID.a)
            : e.to_meter = e.UNIT.convert));
        var n = e.GEOGCS;
        "GEOGCS" === e.type && (n = e), n && (n.DATUM ? e.datumCode = n.DATUM.name.toLowerCase()
            : e.datumCode = n.name.toLowerCase(), "d_" === e.datumCode.slice(0, 2)
        && (e.datumCode = e.datumCode.slice(2)), "new_zealand_geodetic_datum_1949"
        !== e.datumCode
        && "new_zealand_1949" !== e.datumCode || (e.datumCode = "nzgd49"), "wgs_1984"
        !== e.datumCode
        && "world_geodetic_system_1984" !== e.datumCode || ("Mercator_Auxiliary_Sphere"
        === e.PROJECTION && (e.sphere = !0), e.datumCode = "wgs84"), "_ferro"
        === e.datumCode.slice(
            -6) && (e.datumCode = e.datumCode.slice(0, -6)), "_jakarta" === e.datumCode.slice(
            -8)
        && (e.datumCode = e.datumCode.slice(0, -8)), ~e.datumCode.indexOf("belge")
        && (e.datumCode = "rnb72"), n.DATUM && n.DATUM.SPHEROID
        && (e.ellps = n.DATUM.SPHEROID.name.replace("_19", "").replace(/[Cc]larke\_18/,
            "clrk"), "international" === e.ellps.toLowerCase().slice(0, 13)
        && (e.ellps = "intl"), e.a = n.DATUM.SPHEROID.a, e.rf = parseFloat(n.DATUM.SPHEROID.rf,
            10)), n.DATUM && n.DATUM.TOWGS84
        && (e.datum_params = n.DATUM.TOWGS84), ~e.datumCode.indexOf("osgb_1936")
        && (e.datumCode = "osgb36"), ~e.datumCode.indexOf("osni_1952")
        && (e.datumCode = "osni52"), (~e.datumCode.indexOf("tm65") || ~e.datumCode.indexOf(
            "geodetic_datum_of_1965")) && (e.datumCode = "ire65"), "ch1903+" === e.datumCode
        && (e.datumCode = "ch1903"), ~e.datumCode.indexOf("israel")
        && (e.datumCode = "isr93")), e.b
        && !isFinite(e.b) && (e.b = e.a), [["standard_parallel_1", "Standard_Parallel_1"],
          ["standard_parallel_2", "Standard_Parallel_2"], ["false_easting", "False_Easting"],
          ["false_northing", "False_Northing"], ["central_meridian", "Central_Meridian"],
          ["latitude_of_origin", "Latitude_Of_Origin"],
          ["latitude_of_origin", "Central_Parallel"],
          ["scale_factor", "Scale_Factor"], ["k0", "scale_factor"],
          ["latitude_of_center", "Latitude_Of_Center"],
          ["latitude_of_center", "Latitude_of_center"],
          ["lat0", "latitude_of_center", r], ["longitude_of_center", "Longitude_Of_Center"],
          ["longitude_of_center", "Longitude_of_center"], ["longc", "longitude_of_center", r],
          ["x0", "false_easting", t], ["y0", "false_northing", t],
          ["long0", "central_meridian", r],
          ["lat0", "latitude_of_origin", r], ["lat0", "standard_parallel_1", r],
          ["lat1", "standard_parallel_1", r], ["lat2", "standard_parallel_2", r],
          ["azimuth", "Azimuth"], ["alpha", "azimuth", r], ["srsCode", "name"]].forEach(
            function (t) {
              return s = e, a = (i = t)[0], h = i[1], void (!(a in s) && h in s
                  && (s[a] = s[h], 3
                  === i.length && (s[a] = i[2](s[a]))));
              var s, i, a, h
            }), e.long0 || !e.longc || "Albers_Conic_Equal_Area" !== e.projName
        && "Lambert_Azimuthal_Equal_Area" !== e.projName || (e.long0 = e.longc), e.lat_ts
        || !e.lat1
        || "Stereographic_South_Pole" !== e.projName && "Polar Stereographic (variant B)"
        !== e.projName || (e.lat0 = r(0 < e.lat1 ? 90 : -90), e.lat_ts = e.lat1)
      }

      function l(t) {
        var s = this;
        if (2 === arguments.length) {
          var i = arguments[1];
          "string" == typeof i ? "+" === i.charAt(0) ? l[t] = J(arguments[1]) : l[t] = at(
              arguments[1]) : l[t] = i
        } else if (1 === arguments.length) {
          if (Array.isArray(t)) {
            return t.map(function (t) {
              Array.isArray(t) ? l.apply(s, t) : l(t)
            });
          }
          if ("string" == typeof t) {
            if (t in l) {
              return l[t]
            }
          } else {
            "EPSG" in t ? l["EPSG:" + t.EPSG] = t : "ESRI" in t ? l["ESRI:" + t.ESRI] = t
                : "IAU2000" in t ? l["IAU2000:" + t.IAU2000] = t : console.log(t);
          }

        }
      }

      function E(t) {
        if ("string" != typeof t) {
          return t;
        }
        if (t in l) {
          return l[t];
        }
        if (a = t, lt.some(function (t) {
          return -1 < a.indexOf(t)
        })) {
          var s = at(t);
          if (function (t) {
            var s = k(t, "authority");
            if (s) {
              var i = k(s, "epsg");
              return i && -1 < Mt.indexOf(i)
            }
          }(s)) {
            return l["EPSG:3857"];
          }
          var i = function (t) {
            var s = k(t, "extension");
            if (s) {
              return k(s, "proj4")
            }
          }(s);
          return i ? J(i) : s
        }
        var a;
        return "+" === t[0] ? J(t) : void 0
      }

      function t(t) {
        return t
      }

      function s(t, s) {
        var i = mt.length;
        return t.names ? ((mt[i] = t).names.forEach(function (t) {
          ft[t.toLowerCase()] = i
        }), this) : (console.log(s), !0)
      }

      function q(t, s) {
        if (!(this instanceof q)) {
          return new q(t);
        }
        s = s || function (t) {
          if (t) {
            throw t
          }
        };
        var i, a, h, e, n, r, o, l, M, c, u, f, m, p, d, y, _, x, g, b, v, w, C, P, S, N = E(t);
        "object" == typeof N && (i = q.projections.get(N.projName)) ? (!N.datumCode || "none"
        === N.datumCode || (a = k(_t, N.datumCode)) && (N.datum_params = a.towgs84
            ? a.towgs84.split(
                ",") : null, N.ellps = a.ellipse, N.datumName = a.datumName ? a.datumName
            : N.datumCode), N.k0 = N.k0 || 1, N.axis = N.axis || "enu", N.ellps = N.ellps
            || "wgs84", b = N.a, v = N.b, w = N.rf, C = N.ellps, P = N.sphere, b
        || (b = (S = (S = k(
            dt, C)) || yt).a, v = S.b, w = S.rf), w && !v && (v = (1 - 1 / w) * b), (0 === w
            || Math.abs(b - v) < D) && (P = !0, v = b), m = (h = {
          a: b,
          b: v,
          rf: w,
          sphere: P
        }).a, p = h.b, d = N.R_A, x = ((y = m * m) - (_ = p * p)) / y, g = 0, d ? (y = (m *= 1
            - x
            * (R + x * (L + x * T))) * m, x = 0) : g = Math.sqrt(x), e = {
          es: x,
          e: g,
          ep2: (y - _) / _
        }, n = N.datum
            || (r = N.datumCode, o = N.datum_params, l = h.a, M = h.b, c = e.es, u = e.ep2, (f = {}).datum_type = void 0
            === r || "none" === r ? G : A, o && (f.datum_params = o.map(parseFloat), 0
            === f.datum_params[0] && 0 === f.datum_params[1] && 0 === f.datum_params[2]
            || (f.datum_type = I), 3 < f.datum_params.length && (0 === f.datum_params[3] && 0
                === f.datum_params[4] && 0 === f.datum_params[5] && 0 === f.datum_params[6]
                || (f.datum_type = O, f.datum_params[3] *= j, f.datum_params[4] *= j, f.datum_params[5] *= j, f.datum_params[6] = f.datum_params[6]
                    / 1e6 + 1))), f.a = l, f.b = M, f.es = c, f.ep2 = u, f), ct(this, N), ct(
            this,
            i), this.a = h.a, this.b = h.b, this.rf = h.rf, this.sphere = h.sphere, this.es = e.es, this.e = e.e, this.ep2 = e.ep2, this.datum = n, this.init(), s(
            null, this)) : s(t)
      }

      function M(t, s, i) {
        var a, h, e, n, r = t.x, o = t.y, l = t.z ? t.z : 0;
        if (o < -z && -1.001 * z < o) {
          o = -z;
        } else if (z < o && o < 1.001 * z) {
          o = z;
        } else {
          if (o < -z) {
            return {x: -1 / 0, y: -1 / 0, z: t.z};
          }
          if (z < o) {
            return {x: 1 / 0, y: 1 / 0, z: t.z}
          }
        }
        return r > Math.PI && (r -= 2 * Math.PI), h = Math.sin(o), n = Math.cos(o), e = h * h, {
          x: ((a = i / Math.sqrt(1 - s * e)) + l) * n * Math.cos(r),
          y: (a + l) * n * Math.sin(r),
          z: (a * (1 - s) + l) * h
        }
      }

      function c(t, s, i, a) {
        var h, e, n, r, o, l, M, c, u, f, m, p, d, y = t.x, _ = t.y, x = t.z ? t.z : 0,
            g = Math.sqrt(y * y + _ * _), b = Math.sqrt(y * y + _ * _ + x * x);
        if (g / i < 1e-12) {
          if (p = 0, b / i < 1e-12) {
            return d = -a, {x: t.x, y: t.y, z: t.z}
          }
        } else {
          p = Math.atan2(_, y);
        }
        for (h = x / b, l = (e = g / b) * (1 - s) * (n = 1 / Math.sqrt(
            1 - s * (2 - s) * e * e)), M = h * n, m = 0;
            m++, r = s * (o = i / Math.sqrt(1 - s * M * M)) / (o + (d = g * l + x * M - o * (1
                - s * M
                * M))), f = (u = h * (n = 1 / Math.sqrt(1 - r * (2 - r) * e * e))) * l - (c = e
                * (1
                    - r) * n) * M, l = c, M = u, 1e-24 < f * f && m < 30;) {

        }
        return {x: p, y: Math.atan(u / Math.abs(c)), z: d}
      }

      function u(t) {
        return t === I || t === O
      }

      function i(t) {
        if ("function" == typeof Number.isFinite) {
          if (Number.isFinite(t)) {
            return;
          }
          throw new TypeError("coordinates must be finite numbers")
        }
        if ("number" != typeof t || t != t || !isFinite(t)) {
          throw new TypeError(
              "coordinates must be finite numbers")
        }
      }

      function f(t, s, i) {
        var a, h, e;
        if (Array.isArray(i) && (i = bt(i)), vt(i), t.datum && s.datum
        && (e = s, ((h = t).datum.datum_type === I || h.datum.datum_type === O) && "WGS84"
        !== e.datumCode || (e.datum.datum_type === I || e.datum.datum_type === O) && "WGS84"
        !== h.datumCode) && (i = f(t, a = new q("WGS84"), i), t = a), "enu" !== t.axis
        && (i = gt(t,
            !1, i)), "longlat" === t.projName) {
          i = {
            x: i.x * N,
            y: i.y * N,
            z: i.z || 0
          };
        } else if (t.to_meter && (i = {
          x: i.x * t.to_meter,
          y: i.y * t.to_meter,
          z: i.z || 0
        }), !(i = t.inverse(i))) {
          return;
        }
        return t.from_greenwich && (i.x += t.from_greenwich), i = xt(t.datum, s.datum,
            i), s.from_greenwich && (i = {
          x: i.x - s.from_greenwich,
          y: i.y,
          z: i.z || 0
        }), "longlat" === s.projName ? i = {
          x: i.x * B,
          y: i.y * B,
          z: i.z || 0
        } : (i = s.forward(i), s.to_meter && (i = {
          x: i.x / s.to_meter,
          y: i.y / s.to_meter,
          z: i.z || 0
        })), "enu" !== s.axis ? gt(s, !0, i) : i
      }

      function m(s, i, a) {
        var t, h, e;
        return Array.isArray(a) ? (t = f(s, i, a) || {
          x: NaN,
          y: NaN
        }, 2 < a.length ? void 0 !== s.name && "geocent" === s.name || void 0 !== i.name
        && "geocent"
        === i.name ? "number" == typeof t.z ? [t.x, t.y, t.z].concat(a.splice(3)) : [t.x, t.y,
          a[2]].concat(a.splice(3)) : [t.x, t.y].concat(a.splice(2)) : [t.x, t.y]) : (h = f(s,
            i,
            a), 2 === (e = Object.keys(a)).length || e.forEach(function (t) {
          if (void 0 !== s.name && "geocent" === s.name || void 0 !== i.name && "geocent"
              === i.name) {
            if ("x" === t || "y" === t || "z" === t) {
              return
            }
          } else if ("x" === t || "y" === t) {
            return;
          }
          h[t] = a[t]
        }), h)
      }

      function p(t) {
        return t instanceof q ? t : t.oProj ? t.oProj : q(t)
      }

      function a(s, i, t) {
        s = p(s);
        var a, h = !1;
        return void 0 === i ? (i = s, s = wt, h = !0) : void 0 === i.x && !Array.isArray(i)
            || (t = i, i = s, s = wt, h = !0), i = p(i), t ? m(s, i, t) : (a = {
          forward: function (t) {
            return m(s, i, t)
          }, inverse: function (t) {
            return m(i, s, t)
          }
        }, h && (a.oProj = i), a)
      }

      function d(t, s) {
        return s = s || 5, i = function (t) {
          var s, i, a, h, e, n, r = t.lat, o = t.lon, l = _(r), M = _(o);
          n = Math.floor((o + 180) / 6) + 1, 180 === o && (n = 60), 56 <= r && r < 64 && 3
          <= o && o
          < 12 && (n = 32), 72 <= r && r < 84 && (0 <= o && o < 9 ? n = 31 : 9 <= o && o < 21
              ? n = 33
              : 21 <= o && o < 33 ? n = 35 : 33 <= o && o < 42 && (n = 37)), e = _(
              6 * (n - 1) - 180 + 3), s = 6378137 / Math.sqrt(
              1 - .00669438 * Math.sin(l) * Math.sin(l)), i = Math.tan(l) * Math.tan(
              l), a = .006739496752268451 * Math.cos(l) * Math.cos(l);
          var c = .9996 * s * ((h = Math.cos(l) * (M - e)) + (1 - i + a) * h * h * h / 6 + (5
                  - 18 * i
                  + i * i + 72 * a - .39089081163157013) * h * h * h * h * h / 120) + 5e5,
              u = .9996 * (6378137 * (.9983242984503243 * l - .002514607064228144 * Math.sin(
                          2 * l)
                      + 2639046602129982e-21 * Math.sin(4 * l) - 3.418046101696858e-9 * Math.sin(
                          6 * l))
                  + s * Math.tan(l) * (h * h / 2 + (5 - i + 9 * a + 4 * a * a) * h * h * h * h
                      / 24
                      + (61 - 58 * i + i * i + 600 * a - 2.2240339282485886) * h * h * h * h
                      * h * h
                      / 720));
          return r < 0 && (u += 1e7), {
            northing: Math.round(u),
            easting: Math.round(c),
            zoneNumber: n,
            zoneLetter: function (t) {
              var s = "Z";
              return t <= 84 && 72 <= t ? s = "X" : t < 72 && 64 <= t ? s = "W" : t < 64
              && 56 <= t
                  ? s = "V" : t < 56 && 48 <= t ? s = "U" : t < 48 && 40 <= t ? s = "T"
                      : t < 40 && 32
                      <= t ? s = "S" : t < 32 && 24 <= t ? s = "R" : t < 24 && 16 <= t
                          ? s = "Q" : t < 16
                          && 8 <= t ? s = "P" : t < 8 && 0 <= t ? s = "N" : t < 0 && -8
                          <= t ? s = "M" : t
                          < -8 && -16 <= t ? s = "L" : t < -16 && -24 <= t ? s = "K" : t
                          < -24 && -32 <= t
                              ? s = "J" : t < -32 && -40 <= t ? s = "H" : t < -40 && -48
                              <= t ? s = "G" : t
                              < -48 && -56 <= t ? s = "F" : t < -56 && -64 <= t ? s = "E"
                                  : t < -64 && -72
                                  <= t ? s = "D" : t < -72 && -80 <= t && (s = "C"), s
            }(r)
          }
        }({
          lat: t[1],
          lon: t[0]
        }), a = s, h = "00000" + i.easting, e = "00000" + i.northing, i.zoneNumber
        + i.zoneLetter
        + function (t, s, i) {
          var a = b(i);
          return function (t, s, i) {
            var a = i - 1, h = Pt.charCodeAt(a), e = St.charCodeAt(a), n = h + t - 1,
                r = e + s,
                o = !1;
            return It < n && (n = n - It + Nt - 1, o = !0), (n === kt || h < kt && kt < n
                || (kt < n
                    || h < kt) && o) && n++, (n === Et || h < Et && Et < n || (Et < n || h
                < Et) && o)
            && ++n === kt && n++, It < n && (n = n - It + Nt - 1), o = qt < r && (r = r - qt
                + Nt
                - 1, !0), (r === kt || e < kt && kt < r || (kt < r || e < kt) && o)
            && r++, (r === Et
                || e < Et && Et < r || (Et < r || e < Et) && o) && ++r === kt && r++, qt < r
            && (r = r
                - qt + Nt - 1), String.fromCharCode(n) + String.fromCharCode(r)
          }(Math.floor(t / 1e5), Math.floor(s / 1e5) % 20, a)
        }(i.easting, i.northing, i.zoneNumber) + h.substr(h.length - 5, a) + e.substr(
            e.length - 5,
            a);
        var i, a, h, e
      }

      function y(t) {
        var s = g(v(t.toUpperCase()));
        return s.lat && s.lon ? [s.lon, s.lat] : [(s.left + s.right) / 2,
          (s.top + s.bottom) / 2]
      }

      function _(t) {
        return t * (Math.PI / 180)
      }

      function x(t) {
        return t / Math.PI * 180
      }

      function g(t) {
        var s = t.northing, i = t.easting, a = t.zoneLetter, h = t.zoneNumber;
        if (h < 0 || 60 < h) {
          return null;
        }
        var e, n, r, o, l, M, c, u, f = (1 - Math.sqrt(.99330562)) / (1 + Math.sqrt(.99330562)),
            m = i - 5e5, p = s;
        a < "N" && (p -= 1e7), M = 6 * (h - 1) - 180 + 3, u = (c = p / .9996
            / 6367449.145945056) + (3
            * f / 2 - 27 * f * f * f / 32) * Math.sin(2 * c) + (21 * f * f / 16 - 55 * f * f * f
            * f
            / 32) * Math.sin(4 * c) + 151 * f * f * f / 96 * Math.sin(6 * c), e = 6378137
            / Math.sqrt(
                1 - .00669438 * Math.sin(u) * Math.sin(u)), n = Math.tan(u) * Math.tan(
            u), r = .006739496752268451 * Math.cos(u) * Math.cos(u), o = 6335439.32722994
            / Math.pow(
                1 - .00669438 * Math.sin(u) * Math.sin(u), 1.5), l = m / (.9996 * e);
        var d,
            y = x(y = u - e * Math.tan(u) / o * (l * l / 2 - (5 + 3 * n + 10 * r - 4 * r * r
                - .06065547077041606) * l * l * l * l / 24 + (61 + 90 * n + 298 * r + 45 * n * n
                - 1.6983531815716497 - 3 * r * r) * l * l * l * l * l * l / 720)),
            _ = M + x(_ = (l - (1 + 2 * n + r) * l * l * l / 6 + (5 - 2 * r + 28 * n - 3 * r * r
                + .05391597401814761 + 24 * n * n) * l * l * l * l * l / 120) / Math.cos(u));
        return t.accuracy ? {
          top: (d = g({
            northing: t.northing + t.accuracy,
            easting: t.easting + t.accuracy,
            zoneLetter: t.zoneLetter,
            zoneNumber: t.zoneNumber
          })).lat, right: d.lon, bottom: y, left: _
        } : {lat: y, lon: _}
      }

      function b(t) {
        var s = t % Ct;
        return 0 === s && (s = Ct), s
      }

      function v(t) {
        if (t && 0 === t.length) {
          throw"MGRSPoint coverting from nothing";
        }
        for (var s, i = t.length, a = null, h = "", e = 0; !/[A-Z]/.test(s = t.charAt(e));) {
          if (2 <= e) {
            throw"MGRSPoint bad conversion from: " + t;
          }
          h += s, e++
        }
        var n = parseInt(h, 10);
        if (0 === e || i < e + 3) {
          throw"MGRSPoint bad conversion from: " + t;
        }
        var r = t.charAt(e++);
        if (r <= "A" || "B" === r || "Y" === r || "Z" <= r || "I" === r || "O"
            === r) {
          throw"MGRSPoint zone letter " + r + " not handled: " + t;
        }
        a = t.substring(e, e += 2);
        for (var o = b(n), l = function (t, s) {
          for (var i = Pt.charCodeAt(s - 1), a = 1e5, h = !1; i !== t.charCodeAt(0);) {
            if (++i === kt && i++, i === Et && i++, It < i) {
              if (h) {
                throw"Bad character: " + t;
              }
              i = Nt, h = !0
            }
            a += 1e5
          }
          return a
        }(a.charAt(0), o), M = function (t, s) {
          if ("V" < t) {
            throw"MGRSPoint given invalid Northing " + t;
          }
          for (var i = St.charCodeAt(s - 1), a = 0, h = !1; i !== t.charCodeAt(0);) {
            if (++i === kt && i++, i === Et && i++, qt < i) {
              if (h) {
                throw"Bad character: " + t;
              }
              i = Nt, h = !0
            }
            a += 1e5
          }
          return a
        }(a.charAt(1), o); M < w(r);) {
          M += 2e6;
        }
        var c = i - e;
        if (c % 2
            != 0) {
          throw"MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"
          + t;
        }
        var u, f, m, p = c / 2, d = 0, y = 0;
        return 0 < p && (u = 1e5 / Math.pow(10, p), f = t.substring(e, e + p), d = parseFloat(f)
            * u, m = t.substring(e + p), y = parseFloat(m) * u), {
          easting: d + l,
          northing: y + M,
          zoneLetter: r,
          zoneNumber: n,
          accuracy: u
        }
      }

      function w(t) {
        var s;
        switch (t) {
          case"C":
            s = 11e5;
            break;
          case"D":
            s = 2e6;
            break;
          case"E":
            s = 28e5;
            break;
          case"F":
            s = 37e5;
            break;
          case"G":
            s = 46e5;
            break;
          case"H":
            s = 55e5;
            break;
          case"J":
            s = 64e5;
            break;
          case"K":
            s = 73e5;
            break;
          case"L":
            s = 82e5;
            break;
          case"M":
            s = 91e5;
            break;
          case"N":
            s = 0;
            break;
          case"P":
            s = 8e5;
            break;
          case"Q":
            s = 17e5;
            break;
          case"R":
            s = 26e5;
            break;
          case"S":
            s = 35e5;
            break;
          case"T":
            s = 44e5;
            break;
          case"U":
            s = 53e5;
            break;
          case"V":
            s = 62e5;
            break;
          case"W":
            s = 7e6;
            break;
          case"X":
            s = 79e5;
            break;
          default:
            s = -1
        }
        if (0 <= s) {
          return s;
        }
        throw"Invalid zone letter: " + t
      }

      function C(t, s, i) {
        if (!(this instanceof C)) {
          return new C(t, s, i);
        }
        var a;
        Array.isArray(t) ? (this.x = t[0], this.y = t[1], this.z = t[2] || 0) : "object"
        == typeof t
            ? (this.x = t.x, this.y = t.y, this.z = t.z || 0) : "string" == typeof t && void 0
            === s
                ? (a = t.split(","), this.x = parseFloat(a[0], 10), this.y = parseFloat(a[1],
                    10), this.z = parseFloat(a[2], 10) || 0)
                : (this.x = t, this.y = s, this.z = i
                    || 0), console.warn(
            "proj4.Point will be removed in version 3, use proj4.toPoint")
      }

      function P(t, s, i, a) {
        var h;
        return t < D ? (a.value = Os, h = 0) : (h = Math.atan2(s, i), Math.abs(h) <= U
            ? a.value = Os
            : U < h && h <= z + U ? (a.value = As, h -= z) : z + U < h || h <= -(z + U)
                ? (a.value = Gs, h = 0 <= h ? h - Q : h + Q) : (a.value = js, h += z)), h
      }

      function S(t, s) {
        var i = t + s;
        return i < -Q ? i += F : +Q < i && (i -= F), i
      }

      var I = 1, O = 2, A = 4, G = 5, j = 484813681109536e-20, z = Math.PI / 2,
          R = .16666666666666666,
          L = .04722222222222222, T = .022156084656084655, D = 1e-10, N = .017453292519943295,
          B = 57.29577951308232,
          U = Math.PI / 4, F = 2 * Math.PI, Q = 3.14159265359, W = {
            greenwich: 0,
            lisbon: -9.131906111111,
            paris: 2.337229166667,
            bogota: -74.080916666667,
            madrid: -3.687938888889,
            rome: 12.452333333333,
            bern: 7.439583333333,
            jakarta: 106.807719444444,
            ferro: -17.666666666667,
            brussels: 4.367975,
            stockholm: 18.058277777778,
            athens: 23.7163375,
            oslo: 10.722916666667
          }, X = {ft: {to_meter: .3048}, "us-ft": {to_meter: 1200 / 3937}}, H = /[\s_\-\/\(\)]/g,
          J = function (t) {
            var s, i, a, h = {}, e = t.split("+").map(function (t) {
              return t.trim()
            }).filter(function (t) {
              return t
            }).reduce(function (t, s) {
              var i = s.split("=");
              return i.push(!0), t[i[0].toLowerCase()] = i[1], t
            }, {}), n = {
              proj: "projName", datum: "datumCode", rf: function (t) {
                h.rf = parseFloat(t)
              }, lat_0: function (t) {
                h.lat0 = t * N
              }, lat_1: function (t) {
                h.lat1 = t * N
              }, lat_2: function (t) {
                h.lat2 = t * N
              }, lat_ts: function (t) {
                h.lat_ts = t * N
              }, lon_0: function (t) {
                h.long0 = t * N
              }, lon_1: function (t) {
                h.long1 = t * N
              }, lon_2: function (t) {
                h.long2 = t * N
              }, alpha: function (t) {
                h.alpha = parseFloat(t) * N
              }, lonc: function (t) {
                h.longc = t * N
              }, x_0: function (t) {
                h.x0 = parseFloat(t)
              }, y_0: function (t) {
                h.y0 = parseFloat(t)
              }, k_0: function (t) {
                h.k0 = parseFloat(t)
              }, k: function (t) {
                h.k0 = parseFloat(t)
              }, a: function (t) {
                h.a = parseFloat(t)
              }, b: function (t) {
                h.b = parseFloat(t)
              }, r_a: function () {
                h.R_A = !0
              }, zone: function (t) {
                h.zone = parseInt(t, 10)
              }, south: function () {
                h.utmSouth = !0
              }, towgs84: function (t) {
                h.datum_params = t.split(",").map(function (t) {
                  return parseFloat(t)
                })
              }, to_meter: function (t) {
                h.to_meter = parseFloat(t)
              }, units: function (t) {
                h.units = t;
                var s = k(X, t);
                s && (h.to_meter = s.to_meter)
              }, from_greenwich: function (t) {
                h.from_greenwich = t * N
              }, pm: function (t) {
                var s = k(W, t);
                h.from_greenwich = (s || parseFloat(t)) * N
              }, nadgrids: function (t) {
                "@null" === t ? h.datumCode = "none" : h.nadgrids = t
              }, axis: function (t) {
                3 === t.length && -1 !== "ewnsud".indexOf(t.substr(0, 1)) && -1
                !== "ewnsud".indexOf(
                    t.substr(1, 1)) && -1 !== "ewnsud".indexOf(t.substr(2, 1))
                && (h.axis = t)
              }
            };
            for (s in e) {
              i = e[s], s in n ? "function" == typeof (a = n[s]) ? a(i) : h[a] = i
                  : h[s] = i;
            }
            return "string" == typeof h.datumCode && "WGS84" !== h.datumCode
            && (h.datumCode = h.datumCode.toLowerCase()), h
          }, K = 1, V = /\s/, Z = /[A-Za-z]/, Y = /[A-Za-z84]/, $ = /[,\]]/, tt = /[\d\.E\-\+]/;
      e.prototype.readCharicter = function () {
        var t = this.text[this.place++];
        if (4 !== this.state) {
          for (; V.test(t);) {
            if (this.place >= this.text.length) {
              return;
            }
            t = this.text[this.place++]
          }
        }
        switch (this.state) {
          case K:
            return this.neutral(t);
          case 2:
            return this.keyword(t);
          case 4:
            return this.quoted(t);
          case 5:
            return this.afterquote(t);
          case 3:
            return this.number(t);
          case-1:
            return
        }
      }, e.prototype.afterquote = function (t) {
        if ('"' === t) {
          return this.word += '"', void (this.state = 4);
        }
        if ($.test(t)) {
          return this.word = this.word.trim(), void this.afterItem(t);
        }
        throw new Error("havn't handled \"" + t + '" in afterquote yet, index ' + this.place)
      }, e.prototype.afterItem = function (t) {
        return "," === t ? (null !== this.word && this.currentObject.push(
            this.word), this.word = null, void (this.state = K)) : "]" === t
            ? (this.level--, null
            !== this.word && (this.currentObject.push(
                this.word), this.word = null), this.state = K, this.currentObject = this.stack.pop(), void (this.currentObject
                || (this.state = -1))) : void 0
      }, e.prototype.number = function (t) {
        if (!tt.test(t)) {
          if ($.test(t)) {
            return this.word = parseFloat(this.word), void this.afterItem(t);
          }
          throw new Error("havn't handled \"" + t + '" in number yet, index ' + this.place)
        }
        this.word += t
      }, e.prototype.quoted = function (t) {
        '"' !== t ? this.word += t : this.state = 5
      }, e.prototype.keyword = function (t) {
        if (Y.test(t)) {
          this.word += t;
        } else {
          if ("[" === t) {
            var s = [];
            return s.push(this.word), this.level++, null === this.root ? this.root = s
                : this.currentObject.push(s), this.stack.push(
                this.currentObject), this.currentObject = s, void (this.state = K)
          }
          if (!$.test(t)) {
            throw new Error(
                "havn't handled \"" + t + '" in keyword yet, index ' + this.place);
          }
          this.afterItem(t)
        }
      }, e.prototype.neutral = function (t) {
        if (Z.test(t)) {
          return this.word = t, void (this.state = 2);
        }
        if ('"' === t) {
          return this.word = "", void (this.state = 4);
        }
        if (tt.test(t)) {
          return this.word = t, void (this.state = 3);
        }
        if (!$.test(t)) {
          throw new Error(
              "havn't handled \"" + t + '" in neutral yet, index ' + this.place);
        }
        this.afterItem(t)
      }, e.prototype.output = function () {
        for (; this.place < this.text.length;) {
          this.readCharicter();
        }
        if (-1 === this.state) {
          return this.root;
        }
        throw new Error('unable to parse string "' + this.text + '". State is ' + this.state)
      };
      var st, it = .017453292519943295, at = function (t) {
        var s = new e(t).output(), i = s.shift(), a = s.shift();
        s.unshift(["name", a]), s.unshift(["type", i]);
        var h = {};
        return n(s, h), o(h), h
      };
      (st = l)("EPSG:4326",
          "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"), st(
          "EPSG:4269",
          "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"), st(
          "EPSG:3857",
          "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"), st.WGS84 = st["EPSG:4326"], st["EPSG:3785"] = st["EPSG:3857"], st.GOOGLE = st["EPSG:3857"], st["EPSG:900913"] = st["EPSG:3857"], st["EPSG:102113"] = st["EPSG:3857"];

      function ht(t, s, i) {
        var a = t * s;
        return i / Math.sqrt(1 - a * a)
      }

      function et(t) {
        return t < 0 ? -1 : 1
      }

      function nt(t) {
        return Math.abs(t) <= Q ? t : t - et(t) * F
      }

      function rt(t, s, i) {
        var a = t * i, h = .5 * t, a = Math.pow((1 - a) / (1 + a), h);
        return Math.tan(.5 * (z - s)) / a
      }

      function ot(t, s) {
        for (var i, a, h = .5 * t, e = z - 2 * Math.atan(s), n = 0; n <= 15; n++) {
          if (i = t
              * Math.sin(e), e += a = z - 2 * Math.atan(s * Math.pow((1 - i) / (1 + i), h))
              - e, Math.abs(a) <= 1e-10) {
            return e;
          }
        }
        return -9999
      }

      var lt = ["PROJECTEDCRS", "PROJCRS", "GEOGCS", "GEOCCS", "PROJCS", "LOCAL_CS", "GEODCRS",
            "GEODETICCRS", "GEODETICDATUM", "ENGCRS", "ENGINEERINGCRS"],
          Mt = ["3857", "900913", "3785", "102113"], ct = function (t, s) {
            var i, a;
            if (t = t || {}, !s) {
              return t;
            }
            for (a in s) {
              void 0 !== (i = s[a]) && (t[a] = i);
            }
            return t
          }, ut = [{
            init: function () {
              var t = this.b / this.a;
              this.es = 1 - t * t, "x0" in this || (this.x0 = 0), "y0" in this
              || (this.y0 = 0), this.e = Math.sqrt(this.es), this.lat_ts ? this.sphere
                  ? this.k0 = Math.cos(this.lat_ts) : this.k0 = ht(this.e, Math.sin(this.lat_ts),
                      Math.cos(this.lat_ts)) : this.k0 || (this.k ? this.k0 = this.k
                  : this.k0 = 1)
            },
            forward: function (t) {
              var s, i, a, h, e = t.x, n = t.y;
              return 90 < n * B && n * B < -90 && 180 < e * B && e * B < -180 || Math.abs(
                  Math.abs(n) - z)
              <= D ? null : (h = this.sphere ? (a = this.x0 + this.a * this.k0 * nt(
                      e - this.long0), this.y0 + this.a * this.k0 * Math.log(Math.tan(U + .5 * n)))
                  : (s = Math.sin(n), i = rt(this.e, n, s), a = this.x0 + this.a * this.k0 * nt(
                      e - this.long0), this.y0 - this.a * this.k0 * Math.log(
                      i)), t.x = a, t.y = h, t)
            },
            inverse: function (t) {
              var s, i, a = t.x - this.x0, h = t.y - this.y0;
              if (this.sphere) {
                i = z - 2 * Math.atan(Math.exp(-h / (this.a * this.k0)));
              } else {
                var e = Math.exp(-h / (this.a * this.k0));
                if (-9999 === (i = ot(this.e, e))) {
                  return null
                }
              }
              return s = nt(this.long0 + a / (this.a * this.k0)), t.x = s, t.y = i, t
            },
            names: ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP",
              "Mercator_Auxiliary_Sphere", "merc"]
          }, {
            init: function () {
            }, forward: t, inverse: t, names: ["longlat", "identity"]
          }], ft = {}, mt = [], pt = {
            start: function () {
              ut.forEach(s)
            }, add: s, get: function (t) {
              if (!t) {
                return !1;
              }
              var s = t.toLowerCase();
              return void 0 !== ft[s] && mt[ft[s]] ? mt[ft[s]] : void 0
            }
          }, dt = {
            MERIT: {a: 6378137, rf: 298.257, ellipseName: "MERIT 1983"},
            SGS85: {a: 6378136, rf: 298.257, ellipseName: "Soviet Geodetic System 85"},
            GRS80: {a: 6378137, rf: 298.257222101, ellipseName: "GRS 1980(IUGG, 1980)"},
            IAU76: {a: 6378140, rf: 298.257, ellipseName: "IAU 1976"},
            airy: {a: 6377563.396, b: 6356256.91, ellipseName: "Airy 1830"},
            APL4: {a: 6378137, rf: 298.25, ellipseName: "Appl. Physics. 1965"},
            NWL9D: {a: 6378145, rf: 298.25, ellipseName: "Naval Weapons Lab., 1965"},
            mod_airy: {a: 6377340.189, b: 6356034.446, ellipseName: "Modified Airy"},
            andrae: {a: 6377104.43, rf: 300, ellipseName: "Andrae 1876 (Den., Iclnd.)"},
            aust_SA: {a: 6378160, rf: 298.25, ellipseName: "Australian Natl & S. Amer. 1969"},
            GRS67: {a: 6378160, rf: 298.247167427, ellipseName: "GRS 67(IUGG 1967)"},
            bessel: {a: 6377397.155, rf: 299.1528128, ellipseName: "Bessel 1841"},
            bess_nam: {a: 6377483.865, rf: 299.1528128, ellipseName: "Bessel 1841 (Namibia)"},
            clrk66: {a: 6378206.4, b: 6356583.8, ellipseName: "Clarke 1866"},
            clrk80: {a: 6378249.145, rf: 293.4663, ellipseName: "Clarke 1880 mod."},
            clrk58: {a: 6378293.645208759, rf: 294.2606763692654, ellipseName: "Clarke 1858"},
            CPM: {a: 6375738.7, rf: 334.29, ellipseName: "Comm. des Poids et Mesures 1799"},
            delmbr: {a: 6376428, rf: 311.5, ellipseName: "Delambre 1810 (Belgium)"},
            engelis: {a: 6378136.05, rf: 298.2566, ellipseName: "Engelis 1985"},
            evrst30: {a: 6377276.345, rf: 300.8017, ellipseName: "Everest 1830"},
            evrst48: {a: 6377304.063, rf: 300.8017, ellipseName: "Everest 1948"},
            evrst56: {a: 6377301.243, rf: 300.8017, ellipseName: "Everest 1956"},
            evrst69: {a: 6377295.664, rf: 300.8017, ellipseName: "Everest 1969"},
            evrstSS: {a: 6377298.556, rf: 300.8017, ellipseName: "Everest (Sabah & Sarawak)"},
            fschr60: {a: 6378166, rf: 298.3, ellipseName: "Fischer (Mercury Datum) 1960"},
            fschr60m: {a: 6378155, rf: 298.3, ellipseName: "Fischer 1960"},
            fschr68: {a: 6378150, rf: 298.3, ellipseName: "Fischer 1968"},
            helmert: {a: 6378200, rf: 298.3, ellipseName: "Helmert 1906"},
            hough: {a: 6378270, rf: 297, ellipseName: "Hough"},
            intl: {a: 6378388, rf: 297, ellipseName: "International 1909 (Hayford)"},
            kaula: {a: 6378163, rf: 298.24, ellipseName: "Kaula 1961"},
            lerch: {a: 6378139, rf: 298.257, ellipseName: "Lerch 1979"},
            mprts: {a: 6397300, rf: 191, ellipseName: "Maupertius 1738"},
            new_intl: {a: 6378157.5, b: 6356772.2, ellipseName: "New International 1967"},
            plessis: {a: 6376523, rf: 6355863, ellipseName: "Plessis 1817 (France)"},
            krass: {a: 6378245, rf: 298.3, ellipseName: "Krassovsky, 1942"},
            SEasia: {a: 6378155, b: 6356773.3205, ellipseName: "Southeast Asia"},
            walbeck: {a: 6376896, b: 6355834.8467, ellipseName: "Walbeck"},
            WGS60: {a: 6378165, rf: 298.3, ellipseName: "WGS 60"},
            WGS66: {a: 6378145, rf: 298.25, ellipseName: "WGS 66"},
            WGS7: {a: 6378135, rf: 298.26, ellipseName: "WGS 72"}
          }, yt = dt.WGS84 = {a: 6378137, rf: 298.257223563, ellipseName: "WGS 84"};
      dt.sphere = {a: 6370997, b: 6370997, ellipseName: "Normal Sphere (r=6370997)"};
      var _t = {
        wgs84: {towgs84: "0,0,0", ellipse: "WGS84", datumName: "WGS84"},
        ch1903: {towgs84: "674.374,15.056,405.346", ellipse: "bessel", datumName: "swiss"},
        ggrs87: {
          towgs84: "-199.87,74.79,246.62",
          ellipse: "GRS80",
          datumName: "Greek_Geodetic_Reference_System_1987"
        },
        nad83: {towgs84: "0,0,0", ellipse: "GRS80", datumName: "North_American_Datum_1983"},
        nad27: {
          nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
          ellipse: "clrk66",
          datumName: "North_American_Datum_1927"
        },
        potsdam: {
          towgs84: "606.0,23.0,413.0",
          ellipse: "bessel",
          datumName: "Potsdam Rauenberg 1950 DHDN"
        },
        carthage: {
          towgs84: "-263.0,6.0,431.0",
          ellipse: "clark80",
          datumName: "Carthage 1934 Tunisia"
        },
        hermannskogel: {
          towgs84: "653.0,-212.0,449.0",
          ellipse: "bessel",
          datumName: "Hermannskogel"
        },
        osni52: {
          towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
          ellipse: "airy",
          datumName: "Irish National"
        },
        ire65: {
          towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
          ellipse: "mod_airy",
          datumName: "Ireland 1965"
        },
        rassadiran: {
          towgs84: "-133.63,-157.5,-158.62",
          ellipse: "intl",
          datumName: "Rassadiran"
        },
        nzgd49: {
          towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
          ellipse: "intl",
          datumName: "New Zealand Geodetic Datum 1949"
        },
        osgb36: {
          towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
          ellipse: "airy",
          datumName: "Airy 1830"
        },
        s_jtsk: {towgs84: "589,76,480", ellipse: "bessel", datumName: "S-JTSK (Ferro)"},
        beduaram: {towgs84: "-106,-87,188", ellipse: "clrk80", datumName: "Beduaram"},
        gunung_segara: {
          towgs84: "-403,684,41",
          ellipse: "bessel",
          datumName: "Gunung Segara Jakarta"
        },
        rnb72: {
          towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
          ellipse: "intl",
          datumName: "Reseau National Belge 1972"
        }
      };
      q.projections = pt, q.projections.start();
      var xt = function (t, s, i) {
            return h = s, ((a = t).datum_type !== h.datum_type || a.a !== h.a || 5e-11 < Math.abs(
                a.es - h.es) || (a.datum_type === I ? a.datum_params[0] !== h.datum_params[0]
                || a.datum_params[1] !== h.datum_params[1] || a.datum_params[2]
                !== h.datum_params[2]
                : a.datum_type === O && (a.datum_params[0] !== h.datum_params[0]
                || a.datum_params[1]
                !== h.datum_params[1] || a.datum_params[2] !== h.datum_params[2]
                || a.datum_params[3]
                !== h.datum_params[3] || a.datum_params[4] !== h.datum_params[4]
                || a.datum_params[5]
                !== h.datum_params[5] || a.datum_params[6] !== h.datum_params[6]))) && t.datum_type
            !== G
            && s.datum_type !== G && (t.es !== s.es || t.a !== s.a || u(t.datum_type) || u(
                s.datum_type))
                ? (i = M(i, t.es, t.a), u(t.datum_type) && (i = function (t, s, i) {
                  if (s === I) {
                    return {x: t.x + i[0], y: t.y + i[1], z: t.z + i[2]};
                  }
                  if (s === O) {
                    var a = i[0], h = i[1], e = i[2], n = i[3], r = i[4], o = i[5], l = i[6];
                    return {
                      x: l * (t.x - o * t.y + r * t.z) + a,
                      y: l * (o * t.x + t.y - n * t.z) + h,
                      z: l * (-r * t.x + n * t.y + t.z) + e
                    }
                  }
                }(i, t.datum_type, t.datum_params)), u(s.datum_type) && (i = function (t, s, i) {
                  if (s === I) {
                    return {x: t.x - i[0], y: t.y - i[1], z: t.z - i[2]};
                  }
                  if (s === O) {
                    var a = i[0], h = i[1], e = i[2], n = i[3], r = i[4], o = i[5], l = i[6],
                        M = (t.x - a) / l,
                        c = (t.y - h) / l, u = (t.z - e) / l;
                    return {x: M + o * c - r * u, y: -o * M + c + n * u, z: r * M - n * c + u}
                  }
                }(i, s.datum_type, s.datum_params)), c(i, s.es, s.a, s.b)) : i;
            var a, h
          }, gt = function (t, s, i) {
            for (var a, h, e = i.x, n = i.y, r = i.z || 0, o = {}, l = 0; l < 3; l++) {
              if (!s || 2
                  !== l
                  || void 0 !== i.z) {
                switch (h = 0 === l ? (a = e, -1 !== "ew".indexOf(t.axis[l])
                    ? "x"
                    : "y") : 1 === l ? (a = n, -1 !== "ns".indexOf(t.axis[l]) ? "y" : "x")
                    : (a = r, "z"), t.axis[l]) {
                  case"e":
                  case"w":
                  case"n":
                  case"s":
                    o[h] = a;
                    break;
                  case"u":
                    void 0 !== i[h] && (o.z = a);
                    break;
                  case"d":
                    void 0 !== i[h] && (o.z = -a);
                    break;
                  default:
                    return null
                }
              }
            }
            return o
          }, bt = function (t) {
            var s = {x: t[0], y: t[1]};
            return 2 < t.length && (s.z = t[2]), 3 < t.length && (s.m = t[3]), s
          }, vt = function (t) {
            i(t.x), i(t.y)
          }, wt = q("WGS84"), Ct = 6, Pt = "AJSAJS", St = "AFAFAF", Nt = 65, kt = 73, Et = 79,
          qt = 86,
          It = 90, Ot = {
            forward: d, inverse: function (t) {
              var s = g(v(t.toUpperCase()));
              return s.lat && s.lon ? [s.lon, s.lat, s.lon, s.lat] : [s.left, s.bottom, s.right,
                s.top]
            }, toPoint: y
          };
      C.fromMGRS = function (t) {
        return new C(y(t))
      }, C.prototype.toMGRS = function (t) {
        return d([this.x, this.y], t)
      };

      function At(t) {
        var s = [];
        s[0] = 1 - t * (.25 + t * (.046875 + t * (.01953125 + t * ts))), s[1] = t * (.75 - t
            * (.046875 + t * (.01953125 + t * ts)));
        var i = t * t;
        return s[2] = i * (.46875 - t * (.013020833333333334 + .007120768229166667
            * t)), i *= t, s[3] = i * (.3645833333333333 - .005696614583333333 * t), s[4] = i
            * t
            * .3076171875, s
      }

      function Gt(t, s, i, a) {
        return i *= s, s *= s, a[0] * t - i * (a[1] + s * (a[2] + s * (a[3] + s * a[4])))
      }

      function jt(t, s, i) {
        for (var a = 1 / (1 - s), h = t, e = 20; e; --e) {
          var n = Math.sin(h), r = 1 - s * n * n;
          if (h -= r = (Gt(h, n, Math.cos(h), i) - t) * (r * Math.sqrt(r)) * a, Math.abs(r)
          < D) {
            return h
          }
        }
        return h
      }

      function zt(t) {
        var s = Math.exp(t);
        return (s - 1 / s) / 2
      }

      function Rt(t, s) {
        t = Math.abs(t), s = Math.abs(s);
        var i = Math.max(t, s), a = Math.min(t, s) / (i || 1);
        return i * Math.sqrt(1 + Math.pow(a, 2))
      }

      function Lt(t) {
        var s, i, a, h = Math.abs(t);
        return s = h * (1 + h / (Rt(1, h) + 1)), h = 0 == (a = (i = 1 + s) - 1) ? s : s
            * Math.log(i)
            / a, t < 0 ? -h : h
      }

      function Tt(t, s) {
        for (var i, a = 2 * Math.cos(2 * s), h = t.length - 1, e = t[h], n = 0; 0 <= --h;) {
          i = a
              * e
              - n + t[h], n = e, e = i;
        }
        return s + i * Math.sin(2 * s)
      }

      function Dt(t, s, i) {
        for (var a, h, e, n, r = Math.sin(s), o = Math.cos(s), l = zt(i),
            M = (e = i, ((n = Math.exp(e)) + 1 / n) / 2), c = 2 * o * M, u = -2 * r * l,
            f = t.length - 1, m = t[f], p = 0, d = 0, y = 0; 0 <= --f;) {
          a = d, h = p, m = c
              * (d = m)
              - a - u * (p = y) + t[f], y = u * d - h + c * p;
        }
        return [(c = r * M) * m - (u = o * l) * y, c * y + u * m]
      }

      function Bt(t, s) {
        return Math.pow((1 - t) / (1 + t), s)
      }

      function Ut(t, s, i, a, h) {
        return t * h - s * Math.sin(2 * h) + i * Math.sin(4 * h) - a * Math.sin(6 * h)
      }

      function Ft(t) {
        return 1 - .25 * t * (1 + t / 16 * (3 + 1.25 * t))
      }

      function Qt(t) {
        return .375 * t * (1 + .25 * t * (1 + .46875 * t))
      }

      function Wt(t) {
        return .05859375 * t * t * (1 + .75 * t)
      }

      function Xt(t) {
        return t * t * t * (35 / 3072)
      }

      function Ht(t, s, i) {
        var a = s * i;
        return t / Math.sqrt(1 - a * a)
      }

      function Jt(t) {
        return Math.abs(t) < z ? t : t - et(t) * Math.PI
      }

      function Kt(t, s, i, a, h) {
        for (var e, n = t / s, r = 0; r < 15; r++) {
          if (n += e = (t - (s * n - i * Math.sin(
                  2 * n) + a
              * Math.sin(4 * n) - h * Math.sin(6 * n))) / (s - 2 * i * Math.cos(2 * n) + 4 * a
              * Math.cos(4 * n) - 6 * h * Math.cos(6 * n)), Math.abs(e) <= 1e-10) {
            return n;
          }
        }
        return NaN
      }

      function Vt(t, s) {
        var i;
        return 1e-7 < t ? (1 - t * t) * (s / (1 - (i = t * s) * i) - .5 / t * Math.log(
            (1 - i) / (1 + i))) : 2 * s
      }

      function Zt(t) {
        return 1 < Math.abs(t) && (t = 1 < t ? 1 : -1), Math.asin(t)
      }

      function Yt(t, s) {
        return t[0] + s * (t[1] + s * (t[2] + s * t[3]))
      }

      var $t, ts = .01068115234375, ss = {
            init: function () {
              this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0
                  : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0
              !== this.lat0 ? this.lat0 : 0, this.es && (this.en = At(this.es), this.ml0 = Gt(
                  this.lat0,
                  Math.sin(this.lat0), Math.cos(this.lat0), this.en))
            }, forward: function (t) {
              var s = t.x, i = t.y, a = nt(s - this.long0), h = Math.sin(i), e = Math.cos(i);
              if (this.es) {
                var n = e * a, r = Math.pow(n, 2), o = this.ep2 * Math.pow(e, 2),
                    l = Math.pow(o, 2),
                    M = Math.abs(e) > D ? Math.tan(i) : 0, c = Math.pow(M, 2),
                    u = Math.pow(c, 2),
                    f = 1 - this.es * Math.pow(h, 2);
                n /= Math.sqrt(f);
                var m = Gt(i, h, e, this.en),
                    p = this.a * (this.k0 * n * (1 + r / 6 * (1 - c + o + r / 20 * (5 - 18 * c
                            + u + 14
                            * o - 58 * c * o + r / 42 * (61 + 179 * u - u * c - 479 * c)))))
                        + this.x0,
                    d = this.a * (this.k0 * (m - this.ml0 + h * a * n / 2 * (1 + r / 12 * (5 - c
                        + 9 * o
                        + 4 * l + r / 30 * (61 + u - 58 * c + 270 * o - 330 * c * o + r / 56
                            * (1385 + 543
                                * u - u * c - 3111 * c)))))) + this.y0
              } else {
                var y = e * Math.sin(a);
                if (Math.abs(Math.abs(y) - 1) < D) {
                  return 93;
                }
                if (p = .5 * this.a * this.k0 * Math.log((1 + y) / (1 - y)) + this.x0, d = e
                    * Math.cos(a)
                    / Math.sqrt(1 - Math.pow(y, 2)), 1 <= (y = Math.abs(d))) {
                  if (D < y - 1) {
                    return 93;
                  }
                  d = 0
                } else {
                  d = Math.acos(d);
                }
                i < 0 && (d = -d), d = this.a * this.k0 * (d - this.lat0) + this.y0
              }
              return t.x = p, t.y = d, t
            }, inverse: function (t) {
              var s, i, a, h, e, n, r, o, l, M, c, u, f, m, p, d, y,
                  _ = (t.x - this.x0) * (1 / this.a),
                  x = (t.y - this.y0) * (1 / this.a);
              return f = this.es ? (l = this.ml0 + x / this.k0, s = jt(l, this.es,
                  this.en), Math.abs(s)
              < z ? (i = Math.sin(s), a = Math.cos(s), h = Math.abs(a) > D ? Math.tan(s)
                  : 0, e = this.ep2
                  * Math.pow(a, 2), n = Math.pow(e, 2), r = Math.pow(h, 2), o = Math.pow(r,
                  2), l = 1
                  - this.es * Math.pow(i, 2), M = _ * Math.sqrt(l) / this.k0, u = s - (l *= h)
                  * (c = Math.pow(M, 2)) / (1 - this.es) * .5 * (1 - c / 12 * (5 + 3 * r - 9 * e
                      * r + e
                      - 4 * n - c / 30 * (61 + 90 * r - 252 * e * r + 45 * o + 46 * e - c / 56
                          * (1385
                              + 3633 * r + 4095 * o + 1574 * o * r)))), nt(
                  this.long0 + M * (1 - c / 6 * (1 + 2 * r + e - c / 20 * (5 + 28 * r + 24 * o + 8
                      * e * r
                      + 6 * e - c / 42 * (61 + 662 * r + 1320 * o + 720 * o * r)))) / a)) : (u = z
                  * et(
                      x), 0)) : (p = .5 * ((m = Math.exp(_ / this.k0)) - 1 / m), d = this.lat0 + x
                  / this.k0, y = Math.cos(d), l = Math.sqrt(
                  (1 - Math.pow(y, 2)) / (1 + Math.pow(p, 2))), u = Math.asin(l), x < 0
              && (u = -u), 0
              == p && 0 === y ? 0 : nt(Math.atan2(p, y) + this.long0)), t.x = f, t.y = u, t
            }, names: ["Transverse_Mercator", "Transverse Mercator", "tmerc"]
          }, is = {
            init: function () {
              if (void 0 === this.es || this.es <= 0) {
                throw new Error(
                    "incorrect elliptical usage");
              }
              this.x0 = void 0 !== this.x0 ? this.x0 : 0, this.y0 = void 0 !== this.y0 ? this.y0
                  : 0, this.long0 = void 0 !== this.long0 ? this.long0 : 0, this.lat0 = void 0
              !== this.lat0 ? this.lat0
                  : 0, this.cgb = [], this.cbg = [], this.utg = [], this.gtu = [];
              var t = this.es / (1 + Math.sqrt(1 - this.es)), s = t / (2 - t), i = s;
              this.cgb[0] = s * (2 + s * (-2 / 3 + s * (s * (116 / 45 + s * (26 / 45 + -2854 / 675
                      * s))
                  - 2))), this.cbg[0] = s * (s * (2 / 3 + s * (4 / 3 + s * (-82 / 45 + s * (32
                  / 45 + 4642
                  / 4725 * s)))) - 2), i *= s, this.cgb[1] = i * (7 / 3 + s * (s * (-227 / 45 + s
                  * (2704
                      / 315 + 2323 / 945 * s)) - 1.6)), this.cbg[1] = i * (5 / 3 + s * (-16 / 15
                  + s * (-13
                      / 9 + s * (904 / 315 + -1522 / 945 * s)))), i *= s, this.cgb[2] = i * (56
                  / 15 + s
                  * (-136 / 35 + s * (-1262 / 105 + 73814 / 2835 * s))), this.cbg[2] = i * (-26
                  / 15 + s
                  * (34 / 21 + s * (1.6 + -12686 / 2835 * s))), i *= s, this.cgb[3] = i * (4279
                  / 630 + s
                  * (-332 / 35 + -399572 / 14175 * s)), this.cbg[3] = i * (1237 / 630 + s
                  * (-24832
                      / 14175 * s - 2.4)), i *= s, this.cgb[4] = i * (4174 / 315 + -144838 / 6237
                  * s), this.cbg[4] = i * (-734 / 315 + 109598 / 31185
                  * s), i *= s, this.cgb[5] = i
                  * (601676 / 22275), this.cbg[5] = i * (444337 / 155925), i = Math.pow(s,
                  2), this.Qn = this.k0 / (1 + s) * (1 + i * (.25 + i * (1 / 64 + i
                  / 256))), this.utg[0] = s * (s * (2 / 3 + s * (-37 / 96 + s * (1 / 360 + s * (81
                  / 512
                  + -96199 / 604800 * s)))) - .5), this.gtu[0] = s * (.5 + s * (-2 / 3 + s * (5
                  / 16 + s
                  * (41 / 180 + s * (-127 / 288 + 7891 / 37800 * s))))), this.utg[1] = i * (-1
                  / 48 + s
                  * (-1 / 15 + s * (437 / 1440 + s * (-46 / 105 + 1118711 / 3870720
                      * s)))), this.gtu[1] = i * (13 / 48 + s * (s * (557 / 1440 + s * (281 / 630
                  + -1983433 / 1935360 * s)) - .6)), i *= s, this.utg[2] = i * (-17 / 480 + s
                  * (37 / 840
                      + s * (209 / 4480 + -5569 / 90720 * s))), this.gtu[2] = i * (61 / 240 + s
                  * (-103 / 140
                      + s * (15061 / 26880 + 167603 / 181440 * s))), i *= s, this.utg[3] = i
                  * (-4397 / 161280
                      + s * (11 / 504 + 830251 / 7257600 * s)), this.gtu[3] = i * (49561 / 161280
                  + s * (-179
                      / 168 + 6601661 / 7257600 * s)), i *= s, this.utg[4] = i * (-4583 / 161280
                  + 108847
                  / 3991680 * s), this.gtu[4] = i * (34729 / 80640 + -3418889 / 1995840
                  * s), i *= s, this.utg[5] = -.03233083094085698
                  * i, this.gtu[5] = .6650675310896665
                  * i;
              var a = Tt(this.cbg, this.lat0);
              this.Zb = -this.Qn * (a + function (t, s) {
                for (var i, a = 2 * Math.cos(s), h = t.length - 1, e = t[h], n = 0;
                    0 <= --h;) {
                  i = a * e
                      - n + t[h], n = e, e = i;
                }
                return Math.sin(s) * i
              }(this.gtu, 2 * a))
            }, forward: function (t) {
              var s = nt(t.x - this.long0), i = t.y, i = Tt(this.cbg, i), a = Math.sin(i),
                  h = Math.cos(i),
                  e = Math.sin(s), n = Math.cos(s);
              i = Math.atan2(a, n * h), s = Math.atan2(e * h, Rt(a, h * n)), s = Lt(Math.tan(s));
              var r, o, l = Dt(this.gtu, 2 * i, 2 * s);
              return i += l[0], s += l[1], o = Math.abs(s) <= 2.623395162778 ? (r = this.a
                  * (this.Qn * s)
                  + this.x0, this.a * (this.Qn * i + this.Zb) + this.y0) : r = 1
                  / 0, t.x = r, t.y = o, t
            }, inverse: function (t) {
              var s, i, a, h, e, n, r, o = (t.x - this.x0) * (1 / this.a),
                  l = (t.y - this.y0) * (1 / this.a);
              return l = (l - this.Zb) / this.Qn, o /= this.Qn, r = Math.abs(o) <= 2.623395162778
                  ? (l += (s = Dt(this.utg, 2 * l, 2 * o))[0], o += s[1], o = Math.atan(
                      zt(o)), i = Math.sin(l), a = Math.cos(l), h = Math.sin(o), e = Math.cos(
                      o), l = Math.atan2(i * e, Rt(h, e * a)), o = Math.atan2(h, e * a), n = nt(
                      o + this.long0), Tt(this.cgb, l)) : n = 1 / 0, t.x = n, t.y = r, t
            }, names: ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"]
          }, as = {
            init: function () {
              var t = function (t, s) {
                if (void 0 === t) {
                  if ((t = Math.floor(30 * (nt(s) + Math.PI) / Math.PI) + 1) < 0) {
                    return 0;
                  }
                  if (60 < t) {
                    return 60
                  }
                }
                return t
              }(this.zone, this.long0);
              if (void 0 === t) {
                throw new Error("unknown utm zone");
              }
              this.lat0 = 0, this.long0 = (6 * Math.abs(t) - 183)
                  * N, this.x0 = 5e5, this.y0 = this.utmSouth ? 1e7
                  : 0, this.k0 = .9996, is.init.apply(
                  this), this.forward = is.forward, this.inverse = is.inverse
            }, names: ["Universal Transverse Mercator System", "utm"], dependsOn: "etmerc"
          }, hs = {
            init: function () {
              var t = Math.sin(this.lat0), s = Math.cos(this.lat0);
              s *= s, this.rc = Math.sqrt(1 - this.es) / (1 - this.es * t
                  * t), this.C = Math.sqrt(
                  1 + this.es * s * s / (1 - this.es)), this.phic0 = Math.asin(
                  t / this.C), this.ratexp = .5 * this.C * this.e, this.K = Math.tan(
                      .5 * this.phic0 + U)
                  / (Math.pow(Math.tan(.5 * this.lat0 + U), this.C) * Bt(this.e * t, this.ratexp))
            }, forward: function (t) {
              var s = t.x, i = t.y;
              return t.y = 2 * Math.atan(
                      this.K * Math.pow(Math.tan(.5 * i + U), this.C) * Bt(this.e * Math.sin(i),
                          this.ratexp))
                  - z, t.x = this.C * s, t
            }, inverse: function (t) {
              for (var s = t.x / this.C, i = t.y,
                  a = Math.pow(Math.tan(.5 * i + U) / this.K, 1 / this.C),
                  h = 20;
                  0 < h && (i = 2 * Math.atan(a * Bt(this.e * Math.sin(t.y), -.5 * this.e))
                      - z, !(Math.abs(i - t.y) < 1e-14)); --h) {
                t.y = i;
              }
              return h ? (t.x = s, t.y = i, t) : null
            }, names: ["gauss"]
          }, es = {
            init: function () {
              hs.init.apply(this), this.rc && (this.sinc0 = Math.sin(
                  this.phic0), this.cosc0 = Math.cos(
                  this.phic0), this.R2 = 2 * this.rc, this.title
              || (this.title = "Oblique Stereographic Alternative"))
            },
            forward: function (t) {
              var s, i, a, h;
              return t.x = nt(t.x - this.long0), hs.forward.apply(this, [t]), s = Math.sin(
                  t.y), i = Math.cos(t.y), a = Math.cos(t.x), h = this.k0 * this.R2 / (1
                  + this.sinc0 * s
                  + this.cosc0 * i * a), t.x = h * i * Math.sin(t.x), t.y = h * (this.cosc0 * s
                  - this.sinc0 * i * a), t.x = this.a * t.x + this.x0, t.y = this.a * t.y
                  + this.y0, t
            },
            inverse: function (t) {
              var s, i, a, h, e, n;
              return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0)
                  / this.a, t.x /= this.k0, t.y /= this.k0, n = (s = Math.sqrt(
                  t.x * t.x + t.y * t.y))
                  ? (i = 2 * Math.atan2(s, this.R2), a = Math.sin(i), h = Math.cos(
                      i), e = Math.asin(
                      h * this.sinc0 + t.y * a * this.cosc0 / s), Math.atan2(t.x * a,
                      s * this.cosc0 * h - t.y * this.sinc0 * a))
                  : (e = this.phic0, 0), t.x = n, t.y = e, hs.inverse.apply(this, [t]), t.x = nt(
                  t.x + this.long0), t
            },
            names: ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic",
              "sterea",
              "Oblique Stereographic Alternative", "Double_Stereographic"]
          }, ns = {
            init: function () {
              this.coslat0 = Math.cos(this.lat0), this.sinlat0 = Math.sin(this.lat0), this.sphere
                  ? 1
                  === this.k0 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= D
                  && (this.k0 = .5 * (1
                      + et(this.lat0) * Math.sin(this.lat_ts))) : (Math.abs(this.coslat0) <= D
                  && (0
                  < this.lat0 ? this.con = 1 : this.con = -1), this.cons = Math.sqrt(
                      Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e)), 1
                  === this.k0
                  && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= D && (this.k0 = .5
                      * this.cons * ht(
                          this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / rt(this.e,
                          this.con * this.lat_ts,
                          this.con * Math.sin(this.lat_ts))), this.ms1 = ht(this.e,
                      this.sinlat0, this.coslat0), this.X0 = 2 * Math.atan(
                      this.ssfn_(this.lat0, this.sinlat0, this.e)) - z, this.cosX0 = Math.cos(
                      this.X0), this.sinX0 = Math.sin(this.X0))
            },
            forward: function (t) {
              var s, i, a, h, e, n, r = t.x, o = t.y, l = Math.sin(o), M = Math.cos(o),
                  c = nt(r - this.long0);
              return Math.abs(Math.abs(r - this.long0) - Math.PI) <= D && Math.abs(o + this.lat0)
              <= D
                  ? (t.x = NaN, t.y = NaN) : this.sphere ? (s = 2 * this.k0 / (1 + this.sinlat0
                      * l
                      + this.coslat0 * M * Math.cos(c)), t.x = this.a * s * M * Math.sin(c)
                      + this.x0, t.y = this.a * s * (this.coslat0 * l - this.sinlat0 * M
                          * Math.cos(c))
                      + this.y0) : (i = 2 * Math.atan(this.ssfn_(o, l, this.e)) - z, h = Math.cos(
                      i), a = Math.sin(i), Math.abs(this.coslat0) <= D ? (e = rt(this.e,
                          o * this.con,
                          this.con * l), n = 2 * this.a * this.k0 * e / this.cons, t.x = this.x0 + n
                          * Math.sin(r - this.long0), t.y = this.y0 - this.con * n * Math.cos(
                          r - this.long0))
                      : (Math.abs(this.sinlat0) < D ? (s = 2 * this.a * this.k0 / (1 + h
                          * Math.cos(
                              c)), t.y = s * a) : (s = 2 * this.a * this.k0 * this.ms1
                          / (this.cosX0 * (1
                              + this.sinX0 * a + this.cosX0 * h * Math.cos(c))), t.y = s
                          * (this.cosX0 * a
                              - this.sinX0 * h * Math.cos(c)) + this.y0), t.x = s * h * Math.sin(
                              c)
                          + this.x0)), t
            },
            inverse: function (t) {
              t.x -= this.x0, t.y -= this.y0;
              var s, i, a, h = Math.sqrt(t.x * t.x + t.y * t.y);
              if (this.sphere) {
                var e = 2 * Math.atan(h / (2 * this.a * this.k0)), n = this.long0,
                    r = this.lat0;
                return h <= D || (r = Math.asin(
                    Math.cos(e) * this.sinlat0 + t.y * Math.sin(e) * this.coslat0 / h), n = nt(
                    Math.abs(this.coslat0) < D ? 0 < this.lat0 ? this.long0 + Math.atan2(t.x,
                        -1 * t.y)
                        : this.long0 + Math.atan2(t.x, t.y) : this.long0 + Math.atan2(
                        t.x * Math.sin(e),
                        h * this.coslat0 * Math.cos(e) - t.y * this.sinlat0 * Math.sin(
                            e)))), t.x = n, t.y = r, t
              }
              if (Math.abs(this.coslat0) <= D) {
                if (h <= D) {
                  return r = this.lat0, n = this.long0, t.x = n, t.y = r, t;
                }
                t.x *= this.con, t.y *= this.con, s = h * this.cons / (2 * this.a
                    * this.k0), r = this.con
                    * ot(this.e, s), n = this.con * nt(
                    this.con * this.long0 + Math.atan2(t.x, -1 * t.y))
              } else {
                i = 2 * Math.atan(
                    h * this.cosX0 / (2 * this.a * this.k0 * this.ms1)), n = this.long0, h <= D
                    ? a = this.X0 : (a = Math.asin(
                        Math.cos(i) * this.sinX0 + t.y * Math.sin(i) * this.cosX0 / h), n = nt(
                        this.long0 + Math.atan2(t.x * Math.sin(i),
                            h * this.cosX0 * Math.cos(i) - t.y * this.sinX0 * Math.sin(i)))), r = -1
                    * ot(
                        this.e, Math.tan(.5 * (z + a)));
              }
              return t.x = n, t.y = r, t
            },
            names: ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"],
            ssfn_: function (t, s, i) {
              return s *= i, Math.tan(.5 * (z + t)) * Math.pow((1 - s) / (1 + s), .5 * i)
            }
          }, rs = {
            init: function () {
              var t = this.lat0;
              this.lambda0 = this.long0;
              var s = Math.sin(t), i = this.a, a = 1 / this.rf, h = 2 * a - Math.pow(a, 2),
                  e = this.e = Math.sqrt(h);
              this.R = this.k0 * i * Math.sqrt(1 - h) / (1 - h * Math.pow(s,
                  2)), this.alpha = Math.sqrt(
                  1 + h / (1 - h) * Math.pow(Math.cos(t), 4)), this.b0 = Math.asin(
                  s / this.alpha);
              var n = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2)),
                  r = Math.log(Math.tan(Math.PI / 4 + t / 2)),
                  o = Math.log((1 + e * s) / (1 - e * s));
              this.K = n - this.alpha * r + this.alpha * e / 2 * o
            }, forward: function (t) {
              var s = Math.log(Math.tan(Math.PI / 4 - t.y / 2)),
                  i = this.e / 2 * Math.log(
                      (1 + this.e * Math.sin(t.y)) / (1 - this.e * Math.sin(t.y))),
                  a = -this.alpha * (s + i) + this.K,
                  h = 2 * (Math.atan(Math.exp(a)) - Math.PI / 4),
                  e = this.alpha * (t.x - this.lambda0),
                  n = Math.atan(
                      Math.sin(e) / (Math.sin(this.b0) * Math.tan(h) + Math.cos(this.b0)
                          * Math.cos(e))),
                  r = Math.asin(
                      Math.cos(this.b0) * Math.sin(h) - Math.sin(this.b0) * Math.cos(h)
                      * Math.cos(e));
              return t.y = this.R / 2 * Math.log((1 + Math.sin(r)) / (1 - Math.sin(r)))
                  + this.y0, t.x = this.R * n + this.x0, t
            }, inverse: function (t) {
              for (var s = t.x - this.x0, i = t.y - this.y0, a = s / this.R,
                  h = 2 * (Math.atan(Math.exp(i / this.R)) - Math.PI / 4), e = Math.asin(
                      Math.cos(this.b0) * Math.sin(h) + Math.sin(this.b0) * Math.cos(h)
                      * Math.cos(a)),
                  n = Math.atan(
                      Math.sin(a) / (Math.cos(this.b0) * Math.cos(a) - Math.sin(this.b0)
                          * Math.tan(h))),
                  r = this.lambda0 + n / this.alpha, o = 0, l = e, M = -1e3, c = 0;
                  1e-7 < Math.abs(l - M);) {
                if (20 < ++c) {
                  return;
                }
                o = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + e / 2)) - this.K) + this.e
                    * Math.log(Math.tan(
                        Math.PI / 4 + Math.asin(this.e * Math.sin(l)) / 2)), M = l, l = 2
                    * Math.atan(Math.exp(o)) - Math.PI / 2
              }
              return t.x = r, t.y = l, t
            }, names: ["somerc"]
          }, os = {
            init: function () {
              this.no_off = this.no_off || !1, this.no_rot = this.no_rot || !1, isNaN(this.k0)
              && (this.k0 = 1);
              var t = Math.sin(this.lat0), s = Math.cos(this.lat0), i = this.e * t;
              this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(s, 4)), this.al = this.a
                  * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - i * i);
              var a, h, e, n, r, o, l, M, c, u, f = rt(this.e, this.lat0, t),
                  m = this.bl / s * Math.sqrt((1 - this.es) / (1 - i * i));
              m * m < 1 && (m = 1), isNaN(this.longc) ? (h = rt(this.e, this.lat1,
                      Math.sin(this.lat1)), e = rt(this.e, this.lat2, Math.sin(this.lat2)), 0
                  <= this.lat0
                      ? this.el = (m + Math.sqrt(m * m - 1)) * Math.pow(f, this.bl) : this.el = (m
                          - Math.sqrt(m * m - 1)) * Math.pow(f, this.bl), n = Math.pow(h,
                      this.bl), r = Math.pow(e, this.bl), o = .5 * ((a = this.el / n) - 1
                      / a), l = (this.el
                      * this.el - r * n) / (this.el * this.el + r * n), M = (r - n) / (r + n), c = nt(
                      this.long1 - this.long2), this.long0 = .5 * (this.long1 + this.long2)
                      - Math.atan(
                          l * Math.tan(.5 * this.bl * c) / M) / this.bl, this.long0 = nt(
                      this.long0), u = nt(
                      this.long1 - this.long0), this.gamma0 = Math.atan(
                      Math.sin(this.bl * u) / o), this.alpha = Math.asin(m * Math.sin(this.gamma0)))
                  : (a = 0
                  <= this.lat0 ? m + Math.sqrt(m * m - 1) : m - Math.sqrt(m * m - 1), this.el = a
                      * Math.pow(
                          f, this.bl), o = .5 * (a - 1 / a), this.gamma0 = Math.asin(
                      Math.sin(this.alpha) / m), this.long0 = this.longc - Math.asin(
                      o * Math.tan(this.gamma0)) / this.bl), this.no_off ? this.uc = 0 : 0
              <= this.lat0
                  ? this.uc = this.al / this.bl * Math.atan2(Math.sqrt(m * m - 1),
                      Math.cos(this.alpha))
                  : this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(m * m - 1),
                      Math.cos(this.alpha))
            },
            forward: function (t) {
              var s, i, a, h, e, n, r, o, l, M = t.x, c = t.y, u = nt(M - this.long0);
              return l = Math.abs(Math.abs(c) - z) <= D ? (s = 0 < c ? -1 : 1, o = this.al
                      / this.bl
                      * Math.log(Math.tan(U + s * this.gamma0 * .5)), -1 * s * z * this.al / this.bl)
                  : (i = rt(this.e, c, Math.sin(c)), h = .5 * ((a = this.el / Math.pow(i,
                          this.bl)) - 1
                      / a), e = .5 * (a + 1 / a), n = Math.sin(this.bl * u), r = (h * Math.sin(
                      this.gamma0) - n * Math.cos(this.gamma0)) / e, o = Math.abs(Math.abs(r) - 1)
                  <= D
                      ? Number.POSITIVE_INFINITY : .5 * this.al * Math.log((1 - r) / (1 + r))
                      / this.bl, Math.abs(Math.cos(this.bl * u)) <= D ? this.al * this.bl * u
                      : this.al
                      * Math.atan2(h * Math.cos(this.gamma0) + n * Math.sin(this.gamma0),
                          Math.cos(this.bl * u)) / this.bl), this.no_rot ? (t.x = this.x0
                  + l, t.y = this.y0 + o) : (l -= this.uc, t.x = this.x0 + o * Math.cos(
                      this.alpha) + l
                  * Math.sin(this.alpha), t.y = this.y0 + l * Math.cos(this.alpha) - o * Math.sin(
                  this.alpha)), t
            },
            inverse: function (t) {
              var s, i;
              this.no_rot ? (i = t.y - this.y0, s = t.x - this.x0) : (i = (t.x - this.x0)
                  * Math.cos(
                      this.alpha) - (t.y - this.y0) * Math.sin(this.alpha), s = (t.y - this.y0)
                  * Math.cos(
                      this.alpha) + (t.x - this.x0) * Math.sin(this.alpha), s += this.uc);
              var a = Math.exp(-1 * this.bl * i / this.al), h = .5 * (a - 1 / a),
                  e = .5 * (a + 1 / a),
                  n = Math.sin(this.bl * s / this.al),
                  r = (n * Math.cos(this.gamma0) + h * Math.sin(this.gamma0)) / e,
                  o = Math.pow(this.el / Math.sqrt((1 + r) / (1 - r)), 1 / this.bl);
              return Math.abs(r - 1) < D ? (t.x = this.long0, t.y = z) : Math.abs(1 + r) < D
                  ? (t.x = this.long0, t.y = -1 * z) : (t.y = ot(this.e, o), t.x = nt(
                      this.long0 - Math.atan2(
                          h * Math.cos(this.gamma0) - n * Math.sin(this.gamma0),
                          Math.cos(this.bl * s / this.al)) / this.bl)), t
            },
            names: ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator",
              "Hotine_Oblique_Mercator_Azimuth_Natural_Origin",
              "Hotine_Oblique_Mercator_Azimuth_Center",
              "omerc"]
          }, ls = {
            init: function () {
              var t, s, i, a, h, e, n, r, o, l;
              this.lat2 || (this.lat2 = this.lat1), this.k0 || (this.k0 = 1), this.x0 = this.x0
                  || 0, this.y0 = this.y0 || 0, Math.abs(this.lat1 + this.lat2) < D || (t = this.b
                  / this.a, this.e = Math.sqrt(1 - t * t), s = Math.sin(this.lat1), i = Math.cos(
                  this.lat1), a = ht(this.e, s, i), h = rt(this.e, this.lat1, s), e = Math.sin(
                  this.lat2), n = Math.cos(this.lat2), r = ht(this.e, e, n), o = rt(this.e,
                  this.lat2,
                  e), l = rt(this.e, this.lat0, Math.sin(this.lat0)), Math.abs(
                  this.lat1 - this.lat2) > D
                  ? this.ns = Math.log(a / r) / Math.log(h / o) : this.ns = s, isNaN(this.ns)
              && (this.ns = s), this.f0 = a / (this.ns * Math.pow(h, this.ns)), this.rh = this.a
                  * this.f0
                  * Math.pow(l, this.ns), this.title || (this.title = "Lambert Conformal Conic"))
            },
            forward: function (t) {
              var s = t.x, i = t.y;
              Math.abs(2 * Math.abs(i) - Math.PI) <= D && (i = et(i) * (z - 2 * D));
              var a, h, e = Math.abs(Math.abs(i) - z);
              if (D < e) {
                a = rt(this.e, i, Math.sin(i)), h = this.a * this.f0 * Math.pow(a,
                    this.ns);
              } else {
                if ((e = i * this.ns) <= 0) {
                  return null;
                }
                h = 0
              }
              var n = this.ns * nt(s - this.long0);
              return t.x = this.k0 * (h * Math.sin(n)) + this.x0, t.y = this.k0 * (this.rh - h
                  * Math.cos(
                      n)) + this.y0, t
            },
            inverse: function (t) {
              var s, i, a, h, e = (t.x - this.x0) / this.k0,
                  n = this.rh - (t.y - this.y0) / this.k0,
                  r = 0 < this.ns ? (s = Math.sqrt(e * e + n * n), 1) : (s = -Math.sqrt(
                      e * e + n * n), -1), o = 0;
              if (0 !== s && (o = Math.atan2(r * e, r * n)), 0 !== s || 0 < this.ns) {
                if (r = 1 / this.ns, i = Math.pow(s / (this.a * this.f0), r), -9999 === (a = ot(
                    this.e,
                    i))) {
                  return null
                }
              } else {
                a = -z;
              }
              return h = nt(o / this.ns + this.long0), t.x = h, t.y = a, t
            },
            names: ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic",
              "Lambert_Conformal_Conic_2SP", "lcc"]
          }, Ms = {
            init: function () {
              this.a = 6377397.155, this.es = .006674372230614, this.e = Math.sqrt(
                  this.es), this.lat0
              || (this.lat0 = .863937979737193), this.long0
              || (this.long0 = .4334234309119251), this.k0
              || (this.k0 = .9999), this.s45 = .785398163397448, this.s90 = 2
                  * this.s45, this.fi0 = this.lat0, this.e2 = this.es, this.e = Math.sqrt(
                  this.e2), this.alfa = Math.sqrt(
                  1 + this.e2 * Math.pow(Math.cos(this.fi0), 4) / (1
                      - this.e2)), this.uq = 1.04216856380474, this.u0 = Math.asin(
                  Math.sin(this.fi0) / this.alfa), this.g = Math.pow(
                  (1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)),
                  this.alfa * this.e / 2), this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(
                      Math.tan(this.fi0 / 2 + this.s45), this.alfa)
                  * this.g, this.k1 = this.k0, this.n0 = this.a * Math.sqrt(1 - this.e2) / (1
                  - this.e2
                  * Math.pow(Math.sin(this.fi0),
                      2)), this.s0 = 1.37008346281555, this.n = Math.sin(
                  this.s0), this.ro0 = this.k1 * this.n0 / Math.tan(this.s0), this.ad = this.s90
                  - this.uq
            }, forward: function (t) {
              var s = t.x, i = t.y, a = nt(s - this.long0),
                  h = Math.pow((1 + this.e * Math.sin(i)) / (1 - this.e * Math.sin(i)),
                      this.alfa * this.e / 2),
                  e = 2 * (Math.atan(this.k * Math.pow(Math.tan(i / 2 + this.s45), this.alfa) / h)
                      - this.s45),
                  n = -a * this.alfa,
                  r = Math.asin(
                      Math.cos(this.ad) * Math.sin(e) + Math.sin(this.ad) * Math.cos(e)
                      * Math.cos(n)),
                  o = Math.asin(Math.cos(e) * Math.sin(n) / Math.cos(r)), l = this.n * o,
                  M = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(
                      Math.tan(r / 2 + this.s45), this.n);
              return t.y = M * Math.cos(l), t.x = M * Math.sin(l), this.czech
              || (t.y *= -1, t.x *= -1), t
            }, inverse: function (t) {
              var s, i, a, h, e, n, r, o = t.x;
              t.x = t.y, t.y = o, this.czech || (t.y *= -1, t.x *= -1), e = Math.sqrt(
                  t.x * t.x + t.y * t.y), h = Math.atan2(t.y, t.x) / Math.sin(this.s0), a = 2
                  * (Math.atan(
                          Math.pow(this.ro0 / e, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45))
                      - this.s45), s = Math.asin(
                  Math.cos(this.ad) * Math.sin(a) - Math.sin(this.ad) * Math.cos(a) * Math.cos(
                      h)), i = Math.asin(Math.cos(a) * Math.sin(h) / Math.cos(s)), t.x = this.long0
                  - i
                  / this.alfa, n = s;
              for (var l = r = 0; t.y = 2 * (Math.atan(
                      Math.pow(this.k, -1 / this.alfa) * Math.pow(Math.tan(s / 2 + this.s45),
                          1 / this.alfa)
                      * Math.pow((1 + this.e * Math.sin(n)) / (1 - this.e * Math.sin(n)), this.e / 2))
                  - this.s45), Math.abs(n - t.y) < 1e-10 && (r = 1), n = t.y, l += 1, 0 === r && l
              < 15;) {

              }
              return 15 <= l ? null : t
            }, names: ["Krovak", "krovak"]
          }, cs = {
            init: function () {
              this.sphere || (this.e0 = Ft(this.es), this.e1 = Qt(this.es), this.e2 = Wt(
                  this.es), this.e3 = Xt(this.es), this.ml0 = this.a * Ut(this.e0, this.e1,
                  this.e2,
                  this.e3, this.lat0))
            }, forward: function (t) {
              var s, i, a, h, e, n, r, o, l, M = t.x, c = t.y, M = nt(M - this.long0);
              return l = this.sphere ? (o = this.a * Math.asin(Math.cos(c) * Math.sin(M)), this.a
              * (Math.atan2(Math.tan(c), Math.cos(M)) - this.lat0)) : (s = Math.sin(
                  c), i = Math.cos(
                  c), a = Ht(this.a, this.e, s), h = Math.tan(c) * Math.tan(c), o = a * (e = M
                  * Math.cos(
                      c)) * (1 - (n = e * e) * h * (1 / 6 - (8 - h + 8 * (r = this.es * i * i / (1
                  - this.es))) * n / 120)), this.a * Ut(this.e0, this.e1, this.e2, this.e3, c)
              - this.ml0
              + a * s / i * n * (.5 + (5 - h + 6 * r) * n / 24)), t.x = o + this.x0, t.y = l
                  + this.y0, t
            }, inverse: function (t) {
              t.x -= this.x0, t.y -= this.y0;
              var s = t.x / this.a, i = t.y / this.a;
              if (this.sphere) {
                var a = i + this.lat0, h = Math.asin(Math.sin(a) * Math.cos(s)),
                    e = Math.atan2(Math.tan(s), Math.cos(a));
              } else {
                var n = this.ml0 / this.a + i, r = Kt(n, this.e0, this.e1, this.e2, this.e3);
                if (Math.abs(Math.abs(r) - z) <= D) {
                  return t.x = this.long0, t.y = z, i < 0
                  && (t.y *= -1), t;
                }
                var o = Ht(this.a, this.e, Math.sin(r)),
                    l = o * o * o / this.a / this.a * (1 - this.es),
                    M = Math.pow(Math.tan(r), 2), c = s * this.a / o, u = c * c;
                h = r - o * Math.tan(r) / l * c * c * (.5 - (1 + 3 * M) * c * c / 24), e = c
                    * (1 - u * (M
                        / 3 + (1 + 3 * M) * M * u / 15)) / Math.cos(r)
              }
              return t.x = nt(e + this.long0), t.y = Jt(h), t
            }, names: ["Cassini", "Cassini_Soldner", "cass"]
          }, us = {
            init: function () {
              var t, s, i, a, h = Math.abs(this.lat0);
              if (Math.abs(h - z) < D ? this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE
                  : Math.abs(
                      h) < D ? this.mode = this.EQUIT : this.mode = this.OBLIQ, 0
              < this.es) {
                switch (this.qp = Vt(this.e, 1), this.mmf = .5 / (1
                    - this.es), this.apa = (s = this.es, (a = [])[0] = .3333333333333333
                    * s, i = s
                    * s, a[0] += .17222222222222222 * i, a[1] = .06388888888888888
                    * i, i *= s, a[0] += .10257936507936508 * i, a[1] += .0664021164021164
                    * i, a[2] = .016415012942191543 * i, a), this.mode) {
                  case this.N_POLE:
                  case this.S_POLE:
                    this.dd = 1;
                    break;
                  case this.EQUIT:
                    this.rq = Math.sqrt(.5 * this.qp), this.dd = 1
                        / this.rq, this.xmf = 1, this.ymf = .5
                        * this.qp;
                    break;
                  case this.OBLIQ:
                    this.rq = Math.sqrt(.5 * this.qp), t = Math.sin(
                        this.lat0), this.sinb1 = Vt(
                            this.e, t)
                        / this.qp, this.cosb1 = Math.sqrt(
                        1 - this.sinb1 * this.sinb1), this.dd = Math.cos(
                        this.lat0) / (Math.sqrt(1 - this.es * t * t) * this.rq
                        * this.cosb1), this.ymf = (this.xmf = this.rq)
                        / this.dd, this.xmf *= this.dd
                }
              } else {
                this.mode === this.OBLIQ && (this.sinph0 = Math.sin(
                    this.lat0), this.cosph0 = Math.cos(this.lat0))
              }
            },
            forward: function (t) {
              var s, i, a, h, e, n, r, o, l, M, c = t.x, u = t.y, c = nt(c - this.long0);
              if (this.sphere) {
                if (e = Math.sin(u), M = Math.cos(u), a = Math.cos(c), this.mode === this.OBLIQ
                || this.mode === this.EQUIT) {
                  if ((i = this.mode === this.EQUIT ? 1 + M * a : 1 + this.sinph0 * e
                      + this.cosph0 * M
                      * a) <= D) {
                    return null;
                  }
                  s = (i = Math.sqrt(2 / i)) * M * Math.sin(c), i *= this.mode === this.EQUIT
                      ? e
                      : this.cosph0 * e - this.sinph0 * M * a
                } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                  if (this.mode === this.N_POLE && (a = -a), Math.abs(u + this.lat0)
                  < D) {
                    return null;
                  }
                  i = U - .5 * u, s = (i = 2 * (this.mode === this.S_POLE ? Math.cos(i)
                          : Math.sin(i)))
                      * Math.sin(c), i *= a
                }
              } else {
                switch (l = o = r = 0, a = Math.cos(c), h = Math.sin(c), e = Math.sin(
                    u), n = Vt(this.e,
                    e), this.mode !== this.OBLIQ && this.mode !== this.EQUIT || (r = n
                    / this.qp, o = Math.sqrt(1 - r * r)), this.mode) {
                  case this.OBLIQ:
                    l = 1 + this.sinb1 * r + this.cosb1 * o * a;
                    break;
                  case this.EQUIT:
                    l = 1 + o * a;
                    break;
                  case this.N_POLE:
                    l = z + u, n = this.qp - n;
                    break;
                  case this.S_POLE:
                    l = u - z, n = this.qp + n
                }
                if (Math.abs(l) < D) {
                  return null;
                }
                switch (this.mode) {
                  case this.OBLIQ:
                  case this.EQUIT:
                    l = Math.sqrt(2 / l), i = this.mode === this.OBLIQ ? this.ymf * l
                        * (this.cosb1 * r
                            - this.sinb1 * o * a) : (l = Math.sqrt(2 / (1 + o * a))) * r
                        * this.ymf, s = this.xmf * l * o * h;
                    break;
                  case this.N_POLE:
                  case this.S_POLE:
                    0 <= n ? (s = (l = Math.sqrt(n)) * h, i = a * (this.mode === this.S_POLE
                            ? l : -l))
                        : s = i = 0
                }
              }
              return t.x = this.a * s + this.x0, t.y = this.a * i + this.y0, t
            },
            inverse: function (t) {
              t.x -= this.x0, t.y -= this.y0;
              var s, i, a, h, e, n, r, o, l, M, c = t.x / this.a, u = t.y / this.a;
              if (this.sphere) {
                var f = 0, m = 0, p = Math.sqrt(c * c + u * u);
                if (1 < (i = .5 * p)) {
                  return null;
                }
                switch (i = 2 * Math.asin(i), this.mode !== this.OBLIQ && this.mode
                !== this.EQUIT
                || (m = Math.sin(i), f = Math.cos(i)), this.mode) {
                  case this.EQUIT:
                    i = Math.abs(p) <= D ? 0 : Math.asin(u * m / p), c *= m, u = f * p;
                    break;
                  case this.OBLIQ:
                    i = Math.abs(p) <= D ? this.lat0 : Math.asin(
                        f * this.sinph0 + u * m * this.cosph0 / p), c *= m
                        * this.cosph0, u = (f
                        - Math.sin(i) * this.sinph0) * p;
                    break;
                  case this.N_POLE:
                    u = -u, i = z - i;
                    break;
                  case this.S_POLE:
                    i -= z
                }
                s = 0 !== u || this.mode !== this.EQUIT && this.mode !== this.OBLIQ
                    ? Math.atan2(c, u) : 0
              } else {
                if (r = 0, this.mode === this.OBLIQ || this.mode === this.EQUIT) {
                  if (c /= this.dd, u *= this.dd, (n = Math.sqrt(c * c + u * u))
                  < D) {
                    return t.x = this.long0, t.y = this.lat0, t;
                  }
                  h = 2 * Math.asin(.5 * n / this.rq), a = Math.cos(h), c *= h = Math.sin(
                      h), u = this.mode === this.OBLIQ ? (r = a * this.sinb1 + u * h
                      * this.cosb1
                      / n, e = this.qp * r, n * this.cosb1 * a - u * this.sinb1 * h) : (r = u
                      * h
                      / n, e = this.qp * r, n * a)
                } else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
                  if (this.mode === this.N_POLE && (u = -u), !(e = c * c + u
                      * u)) {
                    return t.x = this.long0, t.y = this.lat0, t;
                  }
                  r = 1 - e / this.qp, this.mode === this.S_POLE && (r = -r)
                }
                s = Math.atan2(c, u), o = Math.asin(r), l = this.apa, M = o + o, i = o + l[0]
                    * Math.sin(
                        M) + l[1] * Math.sin(M + M) + l[2] * Math.sin(M + M + M)
              }
              return t.x = nt(this.long0 + s), t.y = i, t
            },
            names: ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"],
            S_POLE: 1,
            N_POLE: 2,
            EQUIT: 3,
            OBLIQ: 4
          }, fs = {
            init: function () {
              Math.abs(this.lat1 + this.lat2) < D || (this.temp = this.b / this.a, this.es = 1
                  - Math.pow(
                      this.temp, 2), this.e3 = Math.sqrt(this.es), this.sin_po = Math.sin(
                  this.lat1), this.cos_po = Math.cos(
                  this.lat1), this.t1 = this.sin_po, this.con = this.sin_po, this.ms1 = ht(
                  this.e3,
                  this.sin_po, this.cos_po), this.qs1 = Vt(this.e3, this.sin_po,
                  this.cos_po), this.sin_po = Math.sin(this.lat2), this.cos_po = Math.cos(
                  this.lat2), this.t2 = this.sin_po, this.ms2 = ht(this.e3, this.sin_po,
                  this.cos_po), this.qs2 = Vt(this.e3, this.sin_po,
                  this.cos_po), this.sin_po = Math.sin(
                  this.lat0), this.cos_po = Math.cos(
                  this.lat0), this.t3 = this.sin_po, this.qs0 = Vt(
                  this.e3, this.sin_po, this.cos_po), Math.abs(this.lat1 - this.lat2) > D
                  ? this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1)
                  : this.ns0 = this.con, this.c = this.ms1 * this.ms1 + this.ns0
                  * this.qs1, this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0)
                  / this.ns0)
            }, forward: function (t) {
              var s = t.x, i = t.y;
              this.sin_phi = Math.sin(i), this.cos_phi = Math.cos(i);
              var a = Vt(this.e3, this.sin_phi, this.cos_phi),
                  h = this.a * Math.sqrt(this.c - this.ns0 * a) / this.ns0,
                  e = this.ns0 * nt(s - this.long0),
                  n = h * Math.sin(e) + this.x0, r = this.rh - h * Math.cos(e) + this.y0;
              return t.x = n, t.y = r, t
            }, inverse: function (t) {
              var s, i, a, h, e, n;
              return t.x -= this.x0, t.y = this.rh - t.y + this.y0, a = 0 <= this.ns0
                  ? (s = Math.sqrt(
                      t.x * t.x + t.y * t.y), 1) : (s = -Math.sqrt(
                      t.x * t.x + t.y * t.y), -1), (h = 0) !== s
              && (h = Math.atan2(a * t.x, a * t.y)), a = s * this.ns0 / this.a, n = this.sphere
                  ? Math.asin((this.c - a * a) / (2 * this.ns0)) : (i = (this.c - a * a)
                      / this.ns0, this.phi1z(this.e3, i)), e = nt(
                  h / this.ns0 + this.long0), t.x = e, t.y = n, t
            }, names: ["Albers_Conic_Equal_Area", "Albers", "aea"], phi1z: function (t, s) {
              var i, a, h, e, n = Zt(.5 * s);
              if (t < D) {
                return n;
              }
              for (var r = t * t, o = 1; o <= 25; o++) {
                if (n += e = .5 * (h = 1 - (a = t
                    * (i = Math.sin(
                        n))) * a) * h / Math.cos(n) * (s / (1 - r) - i / h + .5 / t * Math.log(
                    (1 - a) / (1 + a))), Math.abs(e) <= 1e-7) {
                  return n;
                }
              }
              return null
            }
          }, ms = {
            init: function () {
              this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(
                  this.lat0), this.infinity_dist = 1e3 * this.a, this.rc = 1
            }, forward: function (t) {
              var s, i, a = t.x, h = t.y, e = nt(a - this.long0), n = Math.sin(h),
                  r = Math.cos(h),
                  o = Math.cos(e),
                  l = 0 < (s = this.sin_p14 * n + this.cos_p14 * r * o) || Math.abs(s) <= D
                      ? (i = this.x0
                          + this.a * r * Math.sin(e) / s, this.y0 + this.a * (this.cos_p14 * n
                          - this.sin_p14
                          * r * o) / s) : (i = this.x0 + this.infinity_dist * r * Math.sin(
                          e), this.y0
                      + this.infinity_dist * (this.cos_p14 * n - this.sin_p14 * r * o));
              return t.x = i, t.y = l, t
            }, inverse: function (t) {
              var s, i, a, h, e, n;
              return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0)
                  / this.a, t.x /= this.k0, t.y /= this.k0, e = (s = Math.sqrt(
                  t.x * t.x + t.y * t.y))
                  ? (h = Math.atan2(s, this.rc), i = Math.sin(h), a = Math.cos(h), n = Zt(
                      a * this.sin_p14 + t.y * i * this.cos_p14 / s), e = Math.atan2(t.x * i,
                      s * this.cos_p14 * a - t.y * this.sin_p14 * i), nt(this.long0 + e))
                  : (n = this.phic0, 0), t.x = e, t.y = n, t
            }, names: ["gnom"]
          }, ps = {
            init: function () {
              this.sphere || (this.k0 = ht(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)))
            }, forward: function (t) {
              var s, i, a, h = t.x, e = t.y, n = nt(h - this.long0);
              return a = this.sphere ? (i = this.x0 + this.a * n * Math.cos(this.lat_ts), this.y0
              + this.a
              * Math.sin(e) / Math.cos(this.lat_ts)) : (s = Vt(this.e, Math.sin(e)), i = this.x0
                  + this.a
                  * this.k0 * n, this.y0 + this.a * s * .5 / this.k0), t.x = i, t.y = a, t
            }, inverse: function (t) {
              var s, i;
              return t.x -= this.x0, t.y -= this.y0, this.sphere ? (s = nt(
                  this.long0 + t.x / this.a / Math.cos(this.lat_ts)), i = Math.asin(
                  t.y / this.a * Math.cos(this.lat_ts))) : (i = function (t, s) {
                var i = 1 - (1 - t * t) / (2 * t) * Math.log((1 - t) / (1 + t));
                if (Math.abs(Math.abs(s) - i) < 1e-6) {
                  return s < 0 ? -1 * z : z;
                }
                for (var a, h, e, n, r = Math.asin(.5 * s), o = 0; o < 30;
                    o++) {
                  if (h = Math.sin(
                      r), e = Math.cos(r), n = t * h, r += a = Math.pow(1 - n * n, 2) / (2
                          * e)
                      * (s / (1
                          - t * t) - h / (1 - n * n) + .5 / t * Math.log(
                          (1 - n) / (1 + n))), Math.abs(a)
                  <= 1e-10) {
                    return r;
                  }
                }
                return NaN
              }(this.e, 2 * t.y * this.k0 / this.a), s = nt(
                  this.long0 + t.x / (this.a * this.k0))), t.x = s, t.y = i, t
            }, names: ["cea"]
          }, ds = {
            init: function () {
              this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0
                  || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts
                  || 0, this.title = this.title
                  || "Equidistant Cylindrical (Plate Carre)", this.rc = Math.cos(this.lat_ts)
            }, forward: function (t) {
              var s = t.x, i = t.y, a = nt(s - this.long0), h = Jt(i - this.lat0);
              return t.x = this.x0 + this.a * a * this.rc, t.y = this.y0 + this.a * h, t
            }, inverse: function (t) {
              var s = t.x, i = t.y;
              return t.x = nt(this.long0 + (s - this.x0) / (this.a * this.rc)), t.y = Jt(
                  this.lat0 + (i - this.y0) / this.a), t
            }, names: ["Equirectangular", "Equidistant_Cylindrical", "eqc"]
          }, ys = {
            init: function () {
              this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp,
                  2), this.e = Math.sqrt(
                  this.es), this.e0 = Ft(this.es), this.e1 = Qt(this.es), this.e2 = Wt(
                  this.es), this.e3 = Xt(this.es), this.ml0 = this.a * Ut(this.e0, this.e1,
                  this.e2,
                  this.e3, this.lat0)
            }, forward: function (t) {
              var s, i, a, h = t.x, e = t.y, n = nt(h - this.long0), r = n * Math.sin(e);
              return a = this.sphere ? Math.abs(e) <= D ? (i = this.a * n, -1 * this.a
                  * this.lat0)
                  : (i = this.a * Math.sin(r) / Math.tan(e), this.a * (Jt(e - this.lat0) + (1
                      - Math.cos(
                          r)) / Math.tan(e))) : Math.abs(e) <= D ? (i = this.a * n, -1 * this.ml0)
                  : (i = (s = Ht(this.a, this.e, Math.sin(e)) / Math.tan(e)) * Math.sin(r), this.a
                  * Ut(
                      this.e0, this.e1, this.e2, this.e3, e) - this.ml0 + s * (1 - Math.cos(
                      r))), t.x = i
                  + this.x0, t.y = a + this.y0, t
            }, inverse: function (t) {
              var s, i, a, h, e, n, r, o, l = t.x - this.x0, M = t.y - this.y0;
              if (this.sphere) {
                if (Math.abs(M + this.a * this.lat0) <= D) {
                  s = nt(
                      l / this.a + this.long0), i = 0;
                } else {
                  for (var c, u = this.lat0 + M / this.a, f = l * l / this.a / this.a + u * u,
                      m = u,
                      p = 20; p; --p) {
                    if (m += a = -1 * (u * (m * (c = Math.tan(m)) + 1) - m - .5
                        * (m * m
                            + f) * c) / ((m - u) / c - 1), Math.abs(a) <= D) {
                      i = m;
                      break
                    }
                  }
                  s = nt(this.long0 + Math.asin(l * Math.tan(m) / this.a) / Math.sin(i))
                }
              } else if (Math.abs(M + this.ml0) <= D) {
                i = 0, s = nt(
                    this.long0 + l / this.a);
              } else {
                for (u = (this.ml0 + M) / this.a, f = l * l / this.a / this.a + u
                    * u, m = u, p = 20; p;
                    --p) {
                  if (o = this.e * Math.sin(m), h = Math.sqrt(1 - o * o) * Math.tan(
                      m), e = this.a
                      * Ut(this.e0, this.e1, this.e2, this.e3, m), n = this.e0 - 2 * this.e1
                      * Math.cos(
                          2 * m) + 4 * this.e2 * Math.cos(4 * m) - 6 * this.e3 * Math.cos(
                          6 * m), m -= a = (u
                      * (h * (r = e / this.a) + 1) - r - .5 * h * (r * r + f)) / (this.es
                      * Math.sin(2 * m)
                      * (r * r + f - 2 * u * r) / (4 * h) + (u - r) * (h * n - 2 / Math.sin(
                          2 * m))
                      - n), Math.abs(a) <= D) {
                    i = m;
                    break
                  }
                }
                h = Math.sqrt(1 - this.es * Math.pow(Math.sin(i), 2)) * Math.tan(i), s = nt(
                    this.long0 + Math.asin(l * h / this.a) / Math.sin(i))
              }
              return t.x = s, t.y = i, t
            }, names: ["Polyconic", "poly"]
          }, _s = {
            init: function () {
              this.A = [], this.A[1] = .6399175073, this.A[2] = -.1358797613, this.A[3] = .063294409, this.A[4] = -.02526853, this.A[5] = .0117879, this.A[6] = -.0055161, this.A[7] = .0026906, this.A[8] = -.001333, this.A[9] = 67e-5, this.A[10] = -34e-5, this.B_re = [], this.B_im = [], this.B_re[1] = .7557853228, this.B_im[1] = 0, this.B_re[2] = .249204646, this.B_im[2] = .003371507, this.B_re[3] = -.001541739, this.B_im[3] = .04105856, this.B_re[4] = -.10162907, this.B_im[4] = .01727609, this.B_re[5] = -.26623489, this.B_im[5] = -.36249218, this.B_re[6] = -.6870983, this.B_im[6] = -1.1651967, this.C_re = [], this.C_im = [], this.C_re[1] = 1.3231270439, this.C_im[1] = 0, this.C_re[2] = -.577245789, this.C_im[2] = -.007809598, this.C_re[3] = .508307513, this.C_im[3] = -.112208952, this.C_re[4] = -.15094762, this.C_im[4] = .18200602, this.C_re[5] = 1.01418179, this.C_im[5] = 1.64497696, this.C_re[6] = 1.9660549, this.C_im[6] = 2.5127645, this.D = [], this.D[1] = 1.5627014243, this.D[2] = .5185406398, this.D[3] = -.03333098, this.D[4] = -.1052906, this.D[5] = -.0368594, this.D[6] = .007317, this.D[7] = .0122, this.D[8] = .00394, this.D[9] = -.0013
            }, forward: function (t) {
              for (var s = t.x, i = t.y - this.lat0, a = s - this.long0, h = i / j * 1e-5, e = a,
                  n = 1,
                  r = 0, o = 1; o <= 10; o++) {
                n *= h, r += this.A[o] * n;
              }
              var l, M = r, c = e, u = 1, f = 0, m = 0, p = 0;
              for (o = 1; o <= 6; o++) {
                l = f * M + u * c, u = u * M - f * c, f = l, m = m
                    + this.B_re[o]
                    * u - this.B_im[o] * f, p = p + this.B_im[o] * u + this.B_re[o] * f;
              }
              return t.x = p * this.a + this.x0, t.y = m * this.a + this.y0, t
            }, inverse: function (t) {
              var s, i = t.x, a = t.y, h = i - this.x0, e = (a - this.y0) / this.a,
                  n = h / this.a, r = 1,
                  o = 0,
                  l = 0, M = 0;
              for (y = 1; y <= 6; y++) {
                s = o * e + r * n, r = r * e - o * n, o = s, l = l
                    + this.C_re[y]
                    * r - this.C_im[y] * o, M = M + this.C_im[y] * r + this.C_re[y] * o;
              }
              for (var c = 0; c < this.iterations; c++) {
                for (var u, f = l, m = M, p = e, d = n, y = 2; y <= 6; y++) {
                  u = m * l + f
                      * M, f = f * l
                      - m * M, m = u, p += (y - 1) * (this.B_re[y] * f - this.B_im[y]
                      * m), d += (y - 1)
                      * (this.B_im[y] * f + this.B_re[y] * m);
                }
                f = 1, m = 0;
                var _ = this.B_re[1], x = this.B_im[1];
                for (y = 2; y <= 6; y++) {
                  u = m * l + f * M, f = f * l - m * M, m = u, _ += y
                      * (this.B_re[y] * f - this.B_im[y] * m), x += y * (this.B_im[y] * f
                      + this.B_re[y]
                      * m);
                }
                var g = _ * _ + x * x, l = (p * _ + d * x) / g, M = (d * _ - p * x) / g
              }
              var b = l, v = M, w = 1, C = 0;
              for (y = 1; y <= 9; y++) {
                w *= b, C += this.D[y] * w;
              }
              var P = this.lat0 + C * j * 1e5, S = this.long0 + v;
              return t.x = S, t.y = P, t
            }, names: ["New_Zealand_Map_Grid", "nzmg"]
          }, xs = {
            init: function () {
            }, forward: function (t) {
              var s = t.x, i = t.y, a = nt(s - this.long0), h = this.x0 + this.a * a,
                  e = this.y0 + this.a * Math.log(Math.tan(Math.PI / 4 + i / 2.5)) * 1.25;
              return t.x = h, t.y = e, t
            }, inverse: function (t) {
              t.x -= this.x0, t.y -= this.y0;
              var s = nt(this.long0 + t.x / this.a),
                  i = 2.5 * (Math.atan(Math.exp(.8 * t.y / this.a)) - Math.PI / 4);
              return t.x = s, t.y = i, t
            }, names: ["Miller_Cylindrical", "mill"]
          }, gs = {
            init: function () {
              this.sphere ? (this.n = 1, this.m = 0, this.es = 0, this.C_y = Math.sqrt(
                  (this.m + 1) / this.n), this.C_x = this.C_y / (this.m + 1)) : this.en = At(
                  this.es)
            }, forward: function (t) {
              var s = t.x, i = t.y, s = nt(s - this.long0);
              if (this.sphere) {
                if (this.m) {
                  for (var a = this.n * Math.sin(i), h = 20; h; --h) {
                    var e = (this.m * i + Math.sin(i) - a) / (this.m + Math.cos(i));
                    if (i -= e, Math.abs(e) < D) {
                      break
                    }
                  }
                } else {
                  i = 1 !== this.n ? Math.asin(this.n * Math.sin(i)) : i;
                }
                l = this.a * this.C_x * s * (this.m + Math.cos(i)), o = this.a * this.C_y * i
              } else {
                var n = Math.sin(i), r = Math.cos(i), o = this.a * Gt(i, n, r, this.en),
                    l = this.a * s * r / Math.sqrt(1 - this.es * n * n);
              }
              return t.x = l, t.y = o, t
            }, inverse: function (t) {
              var s, i, a, h;
              return t.x -= this.x0, a = t.x / this.a, t.y -= this.y0, s = t.y
                  / this.a, this.sphere
                  ? (s /= this.C_y, a /= this.C_x * (this.m + Math.cos(s)), this.m ? s = Zt(
                      (this.m * s + Math.sin(s)) / this.n) : 1 !== this.n && (s = Zt(
                      Math.sin(s) / this.n)), a = nt(a + this.long0), s = Jt(s)) : (s = jt(
                      t.y / this.a,
                      this.es, this.en), (h = Math.abs(s)) < z ? (h = Math.sin(s), i = this.long0
                      + t.x
                      * Math.sqrt(1 - this.es * h * h) / (this.a * Math.cos(s)), a = nt(i)) : h
                      - D < z
                      && (a = this.long0)), t.x = a, t.y = s, t
            }, names: ["Sinusoidal", "sinu"]
          }, bs = {
            init: function () {
            }, forward: function (t) {
              for (var s = t.x, i = t.y, a = nt(s - this.long0), h = i,
                  e = Math.PI * Math.sin(i); ;) {
                var n = -(h + Math.sin(h) - e) / (1 + Math.cos(h));
                if (h += n, Math.abs(n) < D) {
                  break
                }
              }
              h /= 2, Math.PI / 2 - Math.abs(i) < D && (a = 0);
              var r = .900316316158 * this.a * a * Math.cos(h) + this.x0,
                  o = 1.4142135623731 * this.a * Math.sin(h) + this.y0;
              return t.x = r, t.y = o, t
            }, inverse: function (t) {
              var s, i;
              t.x -= this.x0, t.y -= this.y0, i = t.y / (1.4142135623731 * this.a), .999999999999
              < Math.abs(i) && (i = .999999999999), s = Math.asin(i);
              var a = nt(this.long0 + t.x / (.900316316158 * this.a * Math.cos(s)));
              a < -Math.PI && (a = -Math.PI), a > Math.PI && (a = Math.PI), i = (2 * s + Math.sin(
                      2 * s))
                  / Math.PI, 1 < Math.abs(i) && (i = 1);
              var h = Math.asin(i);
              return t.x = a, t.y = h, t
            }, names: ["Mollweide", "moll"]
          }, vs = {
            init: function () {
              Math.abs(this.lat1 + this.lat2) < D || (this.lat2 = this.lat2
                  || this.lat1, this.temp = this.b / this.a, this.es = 1 - Math.pow(this.temp,
                  2), this.e = Math.sqrt(this.es), this.e0 = Ft(this.es), this.e1 = Qt(
                  this.es), this.e2 = Wt(this.es), this.e3 = Xt(this.es), this.sinphi = Math.sin(
                  this.lat1), this.cosphi = Math.cos(this.lat1), this.ms1 = ht(this.e,
                  this.sinphi,
                  this.cosphi), this.ml1 = Ut(this.e0, this.e1, this.e2, this.e3,
                  this.lat1), Math.abs(
                  this.lat1 - this.lat2) < D ? this.ns = this.sinphi : (this.sinphi = Math.sin(
                  this.lat2), this.cosphi = Math.cos(this.lat2), this.ms2 = ht(this.e,
                  this.sinphi,
                  this.cosphi), this.ml2 = Ut(this.e0, this.e1, this.e2, this.e3,
                  this.lat2), this.ns = (this.ms1 - this.ms2) / (this.ml2
                  - this.ml1)), this.g = this.ml1
                  + this.ms1 / this.ns, this.ml0 = Ut(this.e0, this.e1, this.e2, this.e3,
                  this.lat0), this.rh = this.a * (this.g - this.ml0))
            }, forward: function (t) {
              var s, i, a = t.x, h = t.y;
              i = this.sphere ? this.a * (this.g - h) : (s = Ut(this.e0, this.e1, this.e2,
                  this.e3,
                  h), this.a * (this.g - s));
              var e = this.ns * nt(a - this.long0), n = this.x0 + i * Math.sin(e),
                  r = this.y0 + this.rh - i * Math.cos(e);
              return t.x = n, t.y = r, t
            }, inverse: function (t) {
              var s, i;
              t.x -= this.x0, t.y = this.rh - t.y + this.y0, s = 0 <= this.ns ? (i = Math.sqrt(
                  t.x * t.x + t.y * t.y), 1) : (i = -Math.sqrt(t.x * t.x + t.y * t.y), -1);
              var a = 0;
              if (0 !== i && (a = Math.atan2(s * t.x, s * t.y)), this.sphere) {
                return n = nt(
                    this.long0 + a / this.ns), e = Jt(this.g - i / this.a), t.x = n, t.y = e, t;
              }
              var h = this.g - i / this.a, e = Kt(h, this.e0, this.e1, this.e2, this.e3),
                  n = nt(this.long0 + a / this.ns);
              return t.x = n, t.y = e, t
            }, names: ["Equidistant_Conic", "eqdc"]
          }, ws = {
            init: function () {
              this.R = this.a
            }, forward: function (t) {
              var s, i = t.x, a = t.y, h = nt(i - this.long0);
              Math.abs(a) <= D && (s = this.x0 + this.R * h, d = this.y0);
              var e = Zt(2 * Math.abs(a / Math.PI));
              (Math.abs(h) <= D || Math.abs(Math.abs(a) - z) <= D) && (s = this.x0, d = 0 <= a
                  ? this.y0
                  + Math.PI * this.R * Math.tan(.5 * e) : this.y0 + Math.PI * this.R * -Math.tan(
                  .5 * e));
              var n = .5 * Math.abs(Math.PI / h - h / Math.PI), r = n * n, o = Math.sin(e),
                  l = Math.cos(e),
                  M = l / (o + l - 1), c = M * M, u = M * (2 / o - 1), f = u * u,
                  m = Math.PI * this.R * (n * (M - f) + Math.sqrt(
                      r * (M - f) * (M - f) - (f + r) * (c - f))) / (f + r);
              h < 0 && (m = -m), s = this.x0 + m;
              var p = r + M,
                  m = Math.PI * this.R * (u * p - n * Math.sqrt((f + r) * (1 + r) - p * p)) / (f
                      + r),
                  d = 0 <= a ? this.y0 + m : this.y0 - m;
              return t.x = s, t.y = d, t
            }, inverse: function (t) {
              var s, i, a, h, e, n, r, o, l, M, c, u;
              return t.x -= this.x0, t.y -= this.y0, c = Math.PI * this.R, e = (a = t.x / c) * a
                  + (h = t.y / c) * h, c = 3 * (h * h / (o = -2 * (n = -Math.abs(h) * (1 + e)) + 1
                      + 2 * h
                      * h + e * e) + (2 * (r = n - 2 * h * h + a * a) * r * r / o / o / o - 9 * n * r
                      / o / o)
                  / 27) / (l = (n - r * r / 3 / o) / o) / (M = 2 * Math.sqrt(-l / 3)), 1
              < Math.abs(c)
              && (c = 0 <= c ? 1 : -1), u = Math.acos(c) / 3, i = 0 <= t.y ? (-M * Math.cos(
                  u + Math.PI / 3) - r / 3 / o) * Math.PI : -(-M * Math.cos(u + Math.PI / 3) - r
                      / 3 / o)
                  * Math.PI, s = Math.abs(a) < D ? this.long0 : nt(
                  this.long0 + Math.PI * (e - 1 + Math.sqrt(1 + 2 * (a * a - h * h) + e * e)) / 2
                  / a), t.x = s, t.y = i, t
            }, names: ["Van_der_Grinten_I", "VanDerGrinten", "vandg"]
          }, Cs = {
            init: function () {
              this.sin_p12 = Math.sin(this.lat0), this.cos_p12 = Math.cos(this.lat0)
            }, forward: function (t) {
              var s, i, a, h, e, n, r, o, l, M, c, u, f, m, p, d, y, _, x, g, b, v, w = t.x,
                  C = t.y,
                  P = Math.sin(t.y), S = Math.cos(t.y), N = nt(w - this.long0);
              return this.sphere ? Math.abs(this.sin_p12 - 1) <= D ? (t.x = this.x0 + this.a * (z
                      - C)
                  * Math.sin(N), t.y = this.y0 - this.a * (z - C) * Math.cos(N)) : Math.abs(
                  this.sin_p12 + 1) <= D ? (t.x = this.x0 + this.a * (z + C) * Math.sin(
                  N), t.y = this.y0
                  + this.a * (z + C) * Math.cos(N)) : (_ = this.sin_p12 * P + this.cos_p12 * S
                  * Math.cos(
                      N), y = (d = Math.acos(_)) ? d / Math.sin(d) : 1, t.x = this.x0 + this.a * y
                  * S
                  * Math.sin(N), t.y = this.y0 + this.a * y * (this.cos_p12 * P - this.sin_p12 * S
                  * Math.cos(N))) : (s = Ft(this.es), i = Qt(this.es), a = Wt(this.es), h = Xt(
                  this.es), Math.abs(this.sin_p12 - 1) <= D ? (e = this.a * Ut(s, i, a, h,
                  z), n = this.a
                  * Ut(s, i, a, h, C), t.x = this.x0 + (e - n) * Math.sin(N), t.y = this.y0 - (e
                      - n)
                  * Math.cos(N)) : Math.abs(this.sin_p12 + 1) <= D ? (e = this.a * Ut(s, i, a, h,
                  z), n = this.a * Ut(s, i, a, h, C), t.x = this.x0 + (e + n) * Math.sin(
                  N), t.y = this.y0
                  + (e + n) * Math.cos(N)) : (r = P / S, o = Ht(this.a, this.e,
                  this.sin_p12), l = Ht(
                  this.a, this.e, P), M = Math.atan(
                  (1 - this.es) * r + this.es * o * this.sin_p12 / (l * S)), x = 0
              === (c = Math.atan2(
                  Math.sin(N), this.cos_p12 * Math.tan(M) - this.sin_p12 * Math.cos(N)))
                  ? Math.asin(
                      this.cos_p12 * Math.sin(M) - this.sin_p12 * Math.cos(M)) : Math.abs(
                      Math.abs(c) - Math.PI) <= D ? -Math.asin(
                      this.cos_p12 * Math.sin(M) - this.sin_p12 * Math.cos(M)) : Math.asin(
                      Math.sin(N) * Math.cos(M) / Math.sin(c)), u = this.e * this.sin_p12
                  / Math.sqrt(
                      1 - this.es), d = o * x * (1 - (g = x * x) * (p = (f = this.e * this.cos_p12
                      * Math.cos(
                          c) / Math.sqrt(1 - this.es)) * f) * (1 - p) / 6 + (b = g * x) / 8 * (m = u
                      * f) * (1 - 2
                      * p) + (v = b * x) / 120 * (p * (4 - 7 * p) - 3 * u * u * (1 - 7 * p)) - v * x
                  / 48
                  * m), t.x = this.x0 + d * Math.sin(c), t.y = this.y0 + d * Math.cos(c))), t
            }, inverse: function (t) {
              var s, i, a, h, e, n, r, o, l, M, c, u, f, m, p, d, y, _, x, g, b, v, w;
              if (t.x -= this.x0, t.y -= this.y0, this.sphere) {
                if ((s = Math.sqrt(t.x * t.x + t.y * t.y)) > 2 * z * this.a) {
                  return;
                }
                return i = s / this.a, a = Math.sin(i), h = Math.cos(
                    i), e = this.long0, Math.abs(s) <= D
                    ? n = this.lat0 : (n = Zt(
                        h * this.sin_p12 + t.y * a * this.cos_p12 / s), r = Math.abs(this.lat0)
                        - z, e = nt(
                        Math.abs(r) <= D ? 0 <= this.lat0 ? this.long0 + Math.atan2(t.x, -t.y)
                            : this.long0 - Math.atan2(-t.x, t.y) : this.long0 + Math.atan2(
                            t.x * a,
                            s * this.cos_p12 * h - t.y * this.sin_p12
                            * a))), t.x = e, t.y = n, t
              }
              return o = Ft(this.es), l = Qt(this.es), M = Wt(this.es), c = Xt(this.es), Math.abs(
                  this.sin_p12 - 1) <= D ? (u = this.a * Ut(o, l, M, c, z), s = Math.sqrt(
                  t.x * t.x + t.y * t.y), n = Kt((u - s) / this.a, o, l, M, c), e = nt(
                  this.long0 + Math.atan2(t.x, -1 * t.y))) : Math.abs(this.sin_p12 + 1) <= D
                  ? (u = this.a
                      * Ut(o, l, M, c, z), s = Math.sqrt(t.x * t.x + t.y * t.y), n = Kt(
                      (s - u) / this.a, o,
                      l, M, c), e = nt(this.long0 + Math.atan2(t.x, t.y))) : (s = Math.sqrt(
                      t.x * t.x + t.y * t.y), p = Math.atan2(t.x, t.y), f = Ht(this.a, this.e,
                      this.sin_p12), d = Math.cos(p), _ = -(y = this.e * this.cos_p12 * d) * y
                      / (1
                          - this.es), x = 3 * this.es * (1 - _) * this.sin_p12 * this.cos_p12 * d
                      / (1
                          - this.es), v = 1 - _ * (b = (g = s / f) - _ * (1 + _) * Math.pow(g, 3)
                      / 6 - x * (1 + 3
                          * _) * Math.pow(g, 4) / 24) * b / 2 - g * b * b * b / 6, m = Math.asin(
                      this.sin_p12 * Math.cos(b) + this.cos_p12 * Math.sin(b) * d), e = nt(
                      this.long0 + Math.asin(
                          Math.sin(p) * Math.sin(b) / Math.cos(m))), w = Math.sin(
                      m), n = Math.atan2((w - this.es * v * this.sin_p12) * Math.tan(m),
                      w * (1 - this.es))), t.x = e, t.y = n, t
            }, names: ["Azimuthal_Equidistant", "aeqd"]
          }, Ps = {
            init: function () {
              this.sin_p14 = Math.sin(this.lat0), this.cos_p14 = Math.cos(this.lat0)
            }, forward: function (t) {
              var s, i, a, h = t.x, e = t.y, n = nt(h - this.long0), r = Math.sin(e),
                  o = Math.cos(e),
                  l = Math.cos(n);
              return (0 < (s = this.sin_p14 * r + this.cos_p14 * o * l) || Math.abs(s) <= D)
              && (i = this.a * o * Math.sin(n), a = this.y0 + this.a * (this.cos_p14 * r
                  - this.sin_p14
                  * o * l)), t.x = i, t.y = a, t
            }, inverse: function (t) {
              var s, i, a, h, e, n, r;
              return t.x -= this.x0, t.y -= this.y0, s = Math.sqrt(t.x * t.x + t.y * t.y), i = Zt(
                  s / this.a), a = Math.sin(i), h = Math.cos(i), n = this.long0, Math.abs(s) <= D
                  ? r = this.lat0 : (r = Zt(
                      h * this.sin_p14 + t.y * a * this.cos_p14 / s), e = Math.abs(
                      this.lat0) - z, n = Math.abs(e) <= D ? nt(
                      0 <= this.lat0 ? this.long0 + Math.atan2(t.x, -t.y) : this.long0
                          - Math.atan2(-t.x,
                              t.y)) : nt(this.long0 + Math.atan2(t.x * a,
                      s * this.cos_p14 * h - t.y * this.sin_p14 * a))), t.x = n, t.y = r, t
            }, names: ["ortho"]
          }, Ss = 1, Ns = 2, ks = 3, Es = 4, qs = 5, Is = 6, Os = 1, As = 2, Gs = 3, js = 4, zs = {
            init: function () {
              this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.lat0 = this.lat0
                  || 0, this.long0 = this.long0 || 0, this.lat_ts = this.lat_ts
                  || 0, this.title = this.title || "Quadrilateralized Spherical Cube", this.lat0
              >= z - U
              / 2 ? this.face = qs : this.lat0 <= -(z - U / 2) ? this.face = Is : Math.abs(
                  this.long0)
              <= U ? this.face = Ss : Math.abs(this.long0) <= z + U ? this.face = 0 < this.long0
                      ? Ns : Es
                  : this.face = ks, 0 !== this.es && (this.one_minus_f = 1 - (this.a - this.b)
                  / this.a, this.one_minus_f_squared = this.one_minus_f * this.one_minus_f)
            },
            forward: function (t) {
              var s, i, a, h, e, n, r, o, l, M, c, u, f = {x: 0, y: 0}, m = {value: 0};
              return t.x -= this.long0, s = 0 !== this.es ? Math.atan(
                  this.one_minus_f_squared * Math.tan(t.y)) : t.y, i = t.x, this.face === qs
                  ? (h = z
                      - s, a = U <= i && i <= z + U ? (m.value = Os, i - z) : z + U < i || i
                  <= -(z + U)
                      ? (m.value = As, 0 < i ? i - Q : i + Q) : -(z + U) < i && i <= -U
                          ? (m.value = Gs, i
                          + z) : (m.value = js, i)) : this.face === Is ? (h = z + s, a = U <= i
                      && i <= z + U
                          ? (m.value = Os, z - i) : i < U && -U <= i ? (m.value = As, -i) : i < -U
                          && -(z + U)
                          <= i ? (m.value = Gs, -i - z) : (m.value = js, 0 < i ? Q - i : -i - Q))
                      : (this.face
                      === Ns ? i = S(i, +z) : this.face === ks ? i = S(i, +Q) : this.face === Es
                          && (i = S(i,
                              -z)), M = Math.sin(s), c = Math.cos(s), u = Math.sin(i), r = c
                          * Math.cos(i), o = c
                          * u, l = M, this.face === Ss ? a = P(h = Math.acos(r), l, o, m)
                          : this.face === Ns
                              ? a = P(h = Math.acos(o), l, -r, m) : this.face === ks ? a = P(
                                  h = Math.acos(-r), l, -o,
                                  m) : this.face === Es ? a = P(h = Math.acos(-o), l, r, m)
                                  : (h = a = 0, m.value = Os)), n = Math.atan(
                  12 / Q * (a + Math.acos(Math.sin(a) * Math.cos(U)) - z)), e = Math.sqrt(
                  (1 - Math.cos(h)) / (Math.cos(n) * Math.cos(n)) / (1 - Math.cos(
                      Math.atan(1 / Math.cos(a))))), m.value === As ? n += z : m.value === Gs ? n += Q
                  : m.value === js && (n += 1.5 * Q), f.x = e * Math.cos(n), f.y = e * Math.sin(
                  n), f.x = f.x * this.a + this.x0, f.y = f.y * this.a
                  + this.y0, t.x = f.x, t.y = f.y, t
            },
            inverse: function (t) {
              var s, i, a, h, e, n, r, o, l, M, c, u, f, m, p, d = {lam: 0, phi: 0},
                  y = {value: 0};
              return t.x = (t.x - this.x0) / this.a, t.y = (t.y - this.y0)
                  / this.a, i = Math.atan(
                  Math.sqrt(t.x * t.x + t.y * t.y)), s = Math.atan2(t.y, t.x), 0 <= t.x && t.x
              >= Math.abs(t.y) ? y.value = Os : 0 <= t.y && t.y >= Math.abs(t.x)
                  ? (y.value = As, s -= z)
                  : t.x < 0 && -t.x >= Math.abs(t.y) ? (y.value = Gs, s = s < 0 ? s + Q : s - Q)
                      : (y.value = js, s += z), c = Q / 12 * Math.tan(s), e = Math.sin(c)
                  / (Math.cos(c)
                      - 1 / Math.sqrt(2)), n = Math.atan(e), (r = 1 - (a = Math.cos(s)) * a
                  * (h = Math.tan(
                      i)) * h * (1 - Math.cos(Math.atan(1 / Math.cos(n))))) < -1 ? r = -1 : 1 < r
                  && (r = 1), this.face === qs ? (o = Math.acos(r), d.phi = z - o, y.value === Os
                  ? d.lam = n + z : y.value === As ? d.lam = n < 0 ? n + Q : n - Q : y.value
                  === Gs
                      ? d.lam = n - z : d.lam = n) : this.face === Is ? (o = Math.acos(
                  r), d.phi = o
                  - z, y.value === Os ? d.lam = z - n : y.value === As ? d.lam = -n : y.value
              === Gs
                  ? d.lam = -n - z : d.lam = n < 0 ? -n - Q : Q - n) : (c = (l = r) * l, u = 1
              <= (c += (M = 1 <= c ? 0 : Math.sqrt(1 - c) * Math.sin(n)) * M) ? 0 : Math.sqrt(
                  1 - c), y.value === As ? (c = u, u = -M, M = c) : y.value === Gs
                  ? (u = -u, M = -M)
                  : y.value === js && (c = u, u = M, M = -c), this.face === Ns
                  ? (c = l, l = -u, u = c)
                  : this.face === ks ? (l = -l, u = -u) : this.face === Es
                      && (c = l, l = u, u = -c), d.phi = Math.acos(-M) - z, d.lam = Math.atan2(u,
                  l), this.face === Ns ? d.lam = S(d.lam, -z) : this.face === ks ? d.lam = S(
                      d.lam, -Q)
                  : this.face === Es && (d.lam = S(d.lam, +z))), 0 !== this.es && (f = d.phi < 0
                  ? 1
                  : 0, m = Math.tan(d.phi), p = this.b / Math.sqrt(
                  m * m + this.one_minus_f_squared), d.phi = Math.atan(
                  Math.sqrt(this.a * this.a - p * p) / (this.one_minus_f * p)), f
              && (d.phi = -d.phi)), d.lam += this.long0, t.x = d.lam, t.y = d.phi, t
            },
            names: ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"]
          },
          Rs = [[1, 22199e-21, -715515e-10, 31103e-10],
            [.9986, -482243e-9, -24897e-9, -13309e-10],
            [.9954, -83103e-8, -448605e-10, -9.86701e-7],
            [.99, -.00135364, -59661e-9, 36777e-10],
            [.9822, -.00167442, -449547e-11, -572411e-11],
            [.973, -.00214868, -903571e-10, 1.8736e-8],
            [.96, -.00305085, -900761e-10, 164917e-11],
            [.9427, -.00382792, -653386e-10, -26154e-10],
            [.9216, -.00467746, -10457e-8, 481243e-11],
            [.8962, -.00536223, -323831e-10, -543432e-11],
            [.8679, -.00609363, -113898e-9, 332484e-11],
            [.835, -.00698325, -640253e-10, 9.34959e-7],
            [.7986, -.00755338, -500009e-10, 9.35324e-7],
            [.7597, -.00798324, -35971e-9, -227626e-11],
            [.7186, -.00851367, -701149e-10, -86303e-10],
            [.6732, -.00986209, -199569e-9, 191974e-10],
            [.6213, -.010418, 883923e-10, 624051e-11], [.5722, -.00906601, 182e-6, 624051e-11],
            [.5322, -.00677797, 275608e-9, 624051e-11]],
          Ls = [[-520417e-23, .0124, 121431e-23, -845284e-16],
            [.062, .0124, -1.26793e-9, 4.22642e-10], [.124, .0124, 5.07171e-9, -1.60604e-9],
            [.186, .0123999, -1.90189e-8, 6.00152e-9], [.248, .0124002, 7.10039e-8, -2.24e-8],
            [.31, .0123992, -2.64997e-7, 8.35986e-8], [.372, .0124029, 9.88983e-7, -3.11994e-7],
            [.434, .0123893, -369093e-11, -4.35621e-7],
            [.4958, .0123198, -102252e-10, -3.45523e-7],
            [.5571, .0121916, -154081e-10, -5.82288e-7],
            [.6176, .0119938, -241424e-10, -5.25327e-7],
            [.6769, .011713, -320223e-10, -5.16405e-7],
            [.7346, .0113541, -397684e-10, -6.09052e-7],
            [.7903, .0109107, -489042e-10, -104739e-11],
            [.8435, .0103431, -64615e-9, -1.40374e-9],
            [.8936, .00969686, -64636e-9, -8547e-9], [.9394, .00840947, -192841e-9, -42106e-10],
            [.9761, .00616527, -256e-6, -42106e-10], [1, .00328947, -319159e-9, -42106e-10]],
          Ts = B / 5, Ds = 1 / Ts, Bs = {
            init: function () {
              this.x0 = this.x0 || 0, this.y0 = this.y0 || 0, this.long0 = this.long0
                  || 0, this.es = 0, this.title = this.title || "Robinson"
            }, forward: function (t) {
              var s = nt(t.x - this.long0), i = Math.abs(t.y), a = Math.floor(i * Ts);
              a < 0 ? a = 0 : 18 <= a && (a = 17);
              var h = {x: Yt(Rs[a], i = B * (i - Ds * a)) * s, y: Yt(Ls[a], i)};
              return t.y < 0 && (h.y = -h.y), h.x = h.x * this.a * .8487 + this.x0, h.y = h.y
                  * this.a
                  * 1.3523 + this.y0, h
            }, inverse: function (t) {
              var a = {
                x: (t.x - this.x0) / (.8487 * this.a),
                y: Math.abs(t.y - this.y0) / (1.3523 * this.a)
              };
              if (1 <= a.y) {
                a.x /= Rs[18][0], a.y = t.y < 0 ? -z : z;
              } else {
                var s = Math.floor(18 * a.y);
                for (s < 0 ? s = 0 : 18 <= s && (s = 17); ;) {
                  if (Ls[s][0] > a.y) {
                    --s;
                  } else {
                    if (!(Ls[s + 1][0] <= a.y)) {
                      break;
                    }
                    ++s
                  }
                }
                var h = Ls[s], i = function (t, s, i, a) {
                  for (var h = s; a; --a) {
                    var e = t(h);
                    if (h -= e, Math.abs(e) < i) {
                      break
                    }
                  }
                  return h
                }(function (t) {
                  return (Yt(h, t) - a.y) / (i = t, (s = h)[1] + i * (2 * s[2] + 3 * i
                      * s[3]));
                  var s, i
                }, i = 5 * (a.y - h[0]) / (Ls[s + 1][0] - h[0]), D, 100);
                a.x /= Yt(Rs[s], i), a.y = (5 * s + i) * N, t.y < 0 && (a.y = -a.y)
              }
              return a.x = nt(a.x + this.long0), a
            }, names: ["Robinson", "robin"]
          }, Us = {
            init: function () {
              this.name = "geocent"
            }, forward: function (t) {
              return M(t, this.es, this.a)
            }, inverse: function (t) {
              return c(t, this.es, this.a, this.b)
            }, names: ["Geocentric", "geocentric", "geocent", "Geocent"]
          };
      return a.defaultDatum = "WGS84", a.Proj = q, a.WGS84 = new a.Proj(
          "WGS84"), a.Point = C, a.toPoint = bt, a.defs = l, a.transform = f, a.mgrs = Ot, a.version = "2.6.2", ($t = a).Proj.projections.add(
          ss), $t.Proj.projections.add(is), $t.Proj.projections.add(as), $t.Proj.projections.add(
          es), $t.Proj.projections.add(ns), $t.Proj.projections.add(rs), $t.Proj.projections.add(
          os), $t.Proj.projections.add(ls), $t.Proj.projections.add(Ms), $t.Proj.projections.add(
          cs), $t.Proj.projections.add(us), $t.Proj.projections.add(fs), $t.Proj.projections.add(
          ms), $t.Proj.projections.add(ps), $t.Proj.projections.add(ds), $t.Proj.projections.add(
          ys), $t.Proj.projections.add(_s), $t.Proj.projections.add(xs), $t.Proj.projections.add(
          gs), $t.Proj.projections.add(bs), $t.Proj.projections.add(vs), $t.Proj.projections.add(
          ws), $t.Proj.projections.add(Cs), $t.Proj.projections.add(Ps), $t.Proj.projections.add(
          zs), $t.Proj.projections.add(Bs), $t.Proj.projections.add(Us), a
    });</script>
  ¶
  <script>
    (function (factory) {
      var L, proj4;
      if (typeof define === 'function' && define.amd) {
        // AMD
        define(['leaflet', 'proj4'], factory);
      } else if (typeof module === 'object' && typeof module.exports === "object") {
        // Node/CommonJS
        L = require('leaflet');
        proj4 = require('proj4');
        module.exports = factory(L, proj4);
      } else {
        // Browser globals
        if (typeof window.L === 'undefined' || typeof window.proj4 === 'undefined') {
          throw 'Leaflet and proj4 must be loaded first';
        }
        factory(window.L, window.proj4);
      }
    }(function (L, proj4) {
      if (proj4.__esModule && proj4.default) {
        // If proj4 was bundled as an ES6 module, unwrap it to get
        // to the actual main proj4 object.
        // See discussion in https://github.com/kartena/Proj4Leaflet/pull/147
        proj4 = proj4.default;
      }

      L.Proj = {};

      L.Proj._isProj4Obj = function (a) {
        return (typeof a.inverse !== 'undefined' &&
            typeof a.forward !== 'undefined');
      };

      L.Proj.Projection = L.Class.extend({
        initialize: function (code, def, bounds) {
          var isP4 = L.Proj._isProj4Obj(code);
          this._proj = isP4 ? code : this._projFromCodeDef(code, def);
          this.bounds = isP4 ? def : bounds;
        },

        project: function (latlng) {
          var point = this._proj.forward([latlng.lng, latlng.lat]);
          return new L.Point(point[0], point[1]);
        },

        unproject: function (point, unbounded) {
          var point2 = this._proj.inverse([point.x, point.y]);
          return new L.LatLng(point2[1], point2[0], unbounded);
        },

        _projFromCodeDef: function (code, def) {
          if (def) {
            proj4.defs(code, def);
          } else if (proj4.defs[code] === undefined) {
            var urn = code.split(':');
            if (urn.length > 3) {
              code = urn[urn.length - 3] + ':' + urn[urn.length - 1];
            }
            if (proj4.defs[code] === undefined) {
              throw 'No projection definition for code ' + code;
            }
          }

          return proj4(code);
        }
      });

      L.Proj.CRS = L.Class.extend({
        includes: L.CRS,

        options: {
          transformation: new L.Transformation(1, 0, -1, 0)
        },

        initialize: function (a, b, c) {
          var code,
              proj,
              def,
              options;

          if (L.Proj._isProj4Obj(a)) {
            proj = a;
            code = proj.srsCode;
            options = b || {};

            this.projection = new L.Proj.Projection(proj, options.bounds);
          } else {
            code = a;
            def = b;
            options = c || {};
            this.projection = new L.Proj.Projection(code, def, options.bounds);
          }

          L.Util.setOptions(this, options);
          this.code = code;
          this.transformation = this.options.transformation;

          if (this.options.origin) {
            this.transformation =
                new L.Transformation(1, -this.options.origin[0],
                    -1, this.options.origin[1]);
          }

          if (this.options.scales) {
            this._scales = this.options.scales;
          } else if (this.options.resolutions) {
            this._scales = [];
            for (var i = this.options.resolutions.length - 1; i >= 0; i--) {
              if (this.options.resolutions[i]) {
                this._scales[i] = 1 / this.options.resolutions[i];
              }
            }
          }

          this.infinite = !this.options.bounds;

        },

        scale: function (zoom) {
          var iZoom = Math.floor(zoom),
              baseScale,
              nextScale,
              scaleDiff,
              zDiff;
          if (zoom === iZoom) {
            return this._scales[zoom];
          } else {
            // Non-integer zoom, interpolate
            baseScale = this._scales[iZoom];
            nextScale = this._scales[iZoom + 1];
            scaleDiff = nextScale - baseScale;
            zDiff = (zoom - iZoom);
            return baseScale + scaleDiff * zDiff;
          }
        },

        zoom: function (scale) {
          // Find closest number in this._scales, down
          var downScale = this._closestElement(this._scales, scale),
              downZoom = this._scales.indexOf(downScale),
              nextScale,
              nextZoom,
              scaleDiff;
          // Check if scale is downScale => return array index
          if (scale === downScale) {
            return downZoom;
          }
          if (downScale === undefined) {
            return -Infinity;
          }
          // Interpolate
          nextZoom = downZoom + 1;
          nextScale = this._scales[nextZoom];
          if (nextScale === undefined) {
            return Infinity;
          }
          scaleDiff = nextScale - downScale;
          return (scale - downScale) / scaleDiff + downZoom;
        },

        distance: L.CRS.Earth.distance,

        R: L.CRS.Earth.R,

        /* Get the closest lowest element in an array */
        _closestElement: function (array, element) {
          var low;
          for (var i = array.length; i--;) {
            if (array[i] <= element && (low === undefined || low < array[i])) {
              low = array[i];
            }
          }
          return low;
        }
      });

      L.Proj.GeoJSON = L.GeoJSON.extend({
        initialize: function (geojson, options) {
          this._callLevel = 0;
          L.GeoJSON.prototype.initialize.call(this, geojson, options);
        },

        addData: function (geojson) {
          var crs;

          if (geojson) {
            if (geojson.crs && geojson.crs.type === 'name') {
              crs = new L.Proj.CRS(geojson.crs.properties.name);
            } else if (geojson.crs && geojson.crs.type) {
              crs = new L.Proj.CRS(geojson.crs.type + ':' + geojson.crs.properties.code);
            }

            if (crs !== undefined) {
              this.options.coordsToLatLng = function (coords) {
                var point = L.point(coords[0], coords[1]);
                return crs.projection.unproject(point);
              };
            }
          }

          // Base class' addData might call us recursively, but
          // CRS shouldn't be cleared in that case, since CRS applies
          // to the whole GeoJSON, inluding sub-features.
          this._callLevel++;
          try {
            L.GeoJSON.prototype.addData.call(this, geojson);
          } finally {
            this._callLevel--;
            if (this._callLevel === 0) {
              delete this.options.coordsToLatLng;
            }
          }
        }
      });

      L.Proj.geoJson = function (geojson, options) {
        return new L.Proj.GeoJSON(geojson, options);
      };

      L.Proj.ImageOverlay = L.ImageOverlay.extend({
        initialize: function (url, bounds, options) {
          L.ImageOverlay.prototype.initialize.call(this, url, null, options);
          this._projectedBounds = bounds;
        },

        // Danger ahead: Overriding internal methods in Leaflet.
        // Decided to do this rather than making a copy of L.ImageOverlay
        // and doing very tiny modifications to it.
        // Future will tell if this was wise or not.
        _animateZoom: function (event) {
          var scale = this._map.getZoomScale(event.zoom);
          var northWest = L.point(this._projectedBounds.min.x, this._projectedBounds.max.y);
          var offset = this._projectedToNewLayerPoint(northWest, event.zoom, event.center);

          L.DomUtil.setTransform(this._image, offset, scale);
        },

        _reset: function () {
          var zoom = this._map.getZoom();
          var pixelOrigin = this._map.getPixelOrigin();
          var bounds = L.bounds(
              this._transform(this._projectedBounds.min, zoom)._subtract(pixelOrigin),
              this._transform(this._projectedBounds.max, zoom)._subtract(pixelOrigin)
          );
          var size = bounds.getSize();

          L.DomUtil.setPosition(this._image, bounds.min);
          this._image.style.width = size.x + 'px';
          this._image.style.height = size.y + 'px';
        },

        _projectedToNewLayerPoint: function (point, zoom, center) {
          var viewHalf = this._map.getSize()._divideBy(2);
          var newTopLeft = this._map.project(center, zoom)._subtract(viewHalf)._round();
          var topLeft = newTopLeft.add(this._map._getMapPanePos());

          return this._transform(point, zoom)._subtract(topLeft);
        },

        _transform: function (point, zoom) {
          var crs = this._map.options.crs;
          var transformation = crs.transformation;
          var scale = crs.scale(zoom);

          return transformation.transform(point, scale);
        }
      });

      L.Proj.imageOverlay = function (url, bounds, options) {
        return new L.Proj.ImageOverlay(url, bounds, options);
      };

      return L.Proj;
    }));
  </script>
  ¶
  <style>
    .leaflet-tooltip.leaflet-tooltip-text-only,
    .leaflet-tooltip.leaflet-tooltip-text-only:before,
    .leaflet-tooltip.leaflet-tooltip-text-only:after {
      background: none;
      border: none;
      box-shadow: none;
    }

    .leaflet-tooltip.leaflet-tooltip-text-only.leaflet-tooltip-left {
      margin-left: 5px;
    }

    .leaflet-tooltip.leaflet-tooltip-text-only.leaflet-tooltip-right {
      margin-left: -5px;
    }

    .leaflet-tooltip:after {
      border-right: 6px solid transparent;

    }

    .leaflet-popup-pane .leaflet-popup-tip-container {

      pointer-events: all;

      cursor: pointer;
    }

    .leaflet-map-pane {
      z-index: auto;
    }

    .leaflet-container .leaflet-right-pane img,
    .leaflet-container .leaflet-left-pane img {
      max-width: none !important;
      max-height: none !important;
    }
  </style>
  ¶
  <script>
    (function () {
      function r(e, n, t) {
        function o(i, f) {
          if (!n[i]) {
            if (!e[i]) {
              var c = "function" == typeof require && require;
              if (!f && c) {
                return c(i, !0);
              }
              if (u) {
                return u(i, !0);
              }
              var a = new Error("Cannot find module '" + i + "'");
              throw a.code = "MODULE_NOT_FOUND", a
            }
            var p = n[i] = {exports: {}};
            e[i][0].call(p.exports, function (r) {
              var n = e[i][1][r];
              return o(n || r)
            }, p, p.exports, r, e, n, t)
          }
          return n[i].exports
        }

        for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
          o(t[i]);
        }
        return o
      }

      return r
    })()({
      1: [function (require, module, exports) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = undefined;

        var _util = require("./util");

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) {
              descriptor.writable = true;
            }
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) {
            _defineProperties(Constructor.prototype, protoProps);
          }
          if (staticProps) {
            _defineProperties(Constructor, staticProps);
          }
          return Constructor;
        }

        var ClusterLayerStore = /*#__PURE__*/function () {
          function ClusterLayerStore(group) {
            _classCallCheck(this, ClusterLayerStore);

            this._layers = {};
            this._group = group;
          }

          _createClass(ClusterLayerStore, [{
            key: "add",
            value: function add(layer, id) {
              if (typeof id !== "undefined" && id !== null) {
                if (this._layers[id]) {
                  this._group.removeLayer(this._layers[id]);
                }

                this._layers[id] = layer;
              }

              this._group.addLayer(layer);
            }
          }, {
            key: "remove",
            value: function remove(id) {
              if (typeof id === "undefined" || id === null) {
                return;
              }

              id = (0, _util.asArray)(id);

              for (var i = 0; i < id.length; i++) {
                if (this._layers[id[i]]) {
                  this._group.removeLayer(this._layers[id[i]]);

                  delete this._layers[id[i]];
                }
              }
            }
          }, {
            key: "clear",
            value: function clear() {
              this._layers = {};

              this._group.clearLayers();
            }
          }]);

          return ClusterLayerStore;
        }();

        exports["default"] = ClusterLayerStore;

      }, {"./util": 17}],
      2: [function (require, module, exports) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) {
              descriptor.writable = true;
            }
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) {
            _defineProperties(Constructor.prototype, protoProps);
          }
          if (staticProps) {
            _defineProperties(Constructor, staticProps);
          }
          return Constructor;
        }

        var ControlStore = /*#__PURE__*/function () {
          function ControlStore(map) {
            _classCallCheck(this, ControlStore);

            this._controlsNoId = [];
            this._controlsById = {};
            this._map = map;
          }

          _createClass(ControlStore, [{
            key: "add",
            value: function add(control, id, html) {
              if (typeof id !== "undefined" && id !== null) {
                if (this._controlsById[id]) {
                  this._map.removeControl(this._controlsById[id]);
                }

                this._controlsById[id] = control;
              } else {
                this._controlsNoId.push(control);
              }

              this._map.addControl(control);
            }
          }, {
            key: "get",
            value: function get(id) {
              var control = null;

              if (this._controlsById[id]) {
                control = this._controlsById[id];
              }

              return control;
            }
          }, {
            key: "remove",
            value: function remove(id) {
              if (this._controlsById[id]) {
                var control = this._controlsById[id];

                this._map.removeControl(control);

                delete this._controlsById[id];
              }
            }
          }, {
            key: "clear",
            value: function clear() {
              for (var i = 0; i < this._controlsNoId.length; i++) {
                var control = this._controlsNoId[i];

                this._map.removeControl(control);
              }

              this._controlsNoId = [];

              for (var key in this._controlsById) {
                var _control = this._controlsById[key];

                this._map.removeControl(_control);
              }

              this._controlsById = {};
            }
          }]);

          return ControlStore;
        }();

        exports["default"] = ControlStore;

      }, {}],
      3: [function (require, module, exports) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.getCRS = getCRS;

        var _leaflet = require("./global/leaflet");

        var _leaflet2 = _interopRequireDefault(_leaflet);

        var _proj4leaflet = require("./global/proj4leaflet");

        var _proj4leaflet2 = _interopRequireDefault(_proj4leaflet);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {"default": obj};
        }

// Helper function to instanciate a ICRS instance.
        function getCRS(crsOptions) {
          var crs = _leaflet2["default"].CRS.EPSG3857; // Default Spherical Mercator

          switch (crsOptions.crsClass) {
            case "L.CRS.EPSG3857":
              crs = _leaflet2["default"].CRS.EPSG3857;
              break;

            case "L.CRS.EPSG4326":
              crs = _leaflet2["default"].CRS.EPSG4326;
              break;

            case "L.CRS.EPSG3395":
              crs = _leaflet2["default"].CRS.EPSG3395;
              break;

            case "L.CRS.Simple":
              crs = _leaflet2["default"].CRS.Simple;
              break;

            case "L.Proj.CRS":
              if (crsOptions.options && crsOptions.options.bounds) {
                crsOptions.options.bounds = _leaflet2["default"].bounds(
                    crsOptions.options.bounds);
              }

              if (crsOptions.options && crsOptions.options.transformation) {
                crsOptions.options.transformation = new _leaflet2["default"].Transformation(
                    crsOptions.options.transformation[0],
                    crsOptions.options.transformation[1],
                    crsOptions.options.transformation[2],
                    crsOptions.options.transformation[3]);
              }

              crs = new _proj4leaflet2["default"].CRS(crsOptions.code,
                  crsOptions.proj4def,
                  crsOptions.options);
              break;

            case "L.Proj.CRS.TMS":
              if (crsOptions.options && crsOptions.options.bounds) {
                crsOptions.options.bounds = _leaflet2["default"].bounds(
                    crsOptions.options.bounds);
              }

              if (crsOptions.options && crsOptions.options.transformation) {
                crsOptions.options.transformation = _leaflet2["default"].Transformation(
                    crsOptions.options.transformation[0],
                    crsOptions.options.transformation[1],
                    crsOptions.options.transformation[2],
                    crsOptions.options.transformation[3]);
              } // L.Proj.CRS.TMS is deprecated as of Leaflet 1.x, fall back to L.Proj.CRS
              //crs = new Proj4Leaflet.CRS.TMS(crsOptions.code, crsOptions.proj4def, crsOptions.projectedBounds, crsOptions.options);

              crs = new _proj4leaflet2["default"].CRS(crsOptions.code,
                  crsOptions.proj4def,
                  crsOptions.options);
              break;
          }

          return crs;
        }

      }, {"./global/leaflet": 10, "./global/proj4leaflet": 11}],
      4: [function (require, module, exports) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports["default"] = undefined;

        var _util = require("./util");

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) {
              descriptor.writable = true;
            }
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) {
            _defineProperties(Constructor.prototype, protoProps);
          }
          if (staticProps) {
            _defineProperties(Constructor, staticProps);
          }
          return Constructor;
        }

        var DataFrame = /*#__PURE__*/function () {
          function DataFrame() {
            _classCallCheck(this, DataFrame);

            this.columns = [];
            this.colnames = [];
            this.colstrict = [];
            this.effectiveLength = 0;
            this.colindices = {};
          }

          _createClass(DataFrame, [{
            key: "_updateCachedProperties",
            value: function _updateCachedProperties() {
              var _this = this;

              this.effectiveLength = 0;
              this.colindices = {};
              this.columns.forEach(function (column, i) {
                _this.effectiveLength = Math.max(_this.effectiveLength, column.length);
                _this.colindices[_this.colnames[i]] = i;
              });
            }
          }, {
            key: "_colIndex",
            value: function _colIndex(colname) {
              var index = this.colindices[colname];
              if (typeof index === "undefined") {
                return -1;
              }
              return index;
            }
          }, {
            key: "col",
            value: function col(name, values, strict) {
              if (typeof name !== "string") {
                throw new Error(
                    "Invalid column name \"" + name + "\"");
              }

              var index = this._colIndex(name);

              if (arguments.length === 1) {
                if (index < 0) {
                  return null;
                } else {
                  return (0, _util.recycle)(
                      this.columns[index],
                      this.effectiveLength);
                }
              }

              if (index < 0) {
                index = this.colnames.length;
                this.colnames.push(name);
              }

              this.columns[index] = (0, _util.asArray)(values);
              this.colstrict[index] = !!strict; // TODO: Validate strictness (ensure lengths match up with other stricts)

              this._updateCachedProperties();

              return this;
            }
          }, {
            key: "cbind",
            value: function cbind(obj, strict) {
              var _this2 = this;

              Object.keys(obj).forEach(function (name) {
                var coldata = obj[name];

                _this2.col(name, coldata);
              });
              return this;
            }
          }, {
            key: "get",
            value: function get(row, col, missingOK) {
              var _this3 = this;

              if (row > this.effectiveLength) {
                throw new Error(
                    "Row argument was out of bounds: " + row + " > "
                    + this.effectiveLength);
              }
              var colIndex = -1;

              if (typeof col === "undefined") {
                var rowData = {};
                this.colnames.forEach(function (name, i) {
                  rowData[name] = _this3.columns[i][row % _this3.columns[i].length];
                });
                return rowData;
              } else if (typeof col === "string") {
                colIndex = this._colIndex(col);
              } else if (typeof col === "number") {
                colIndex = col;
              }

              if (colIndex < 0 || colIndex > this.columns.length) {
                if (missingOK) {
                  return void 0;
                } else {
                  throw new Error(
                      "Unknown column index: " + col);
                }
              }

              return this.columns[colIndex][row % this.columns[colIndex].length];
            }
          }, {
            key: "nrow",
            value: function nrow() {
              return this.effectiveLength;
            }
          }]);

          return DataFrame;
        }();

        exports["default"] = DataFrame;

      }, {"./util": 17}],
      5: [function (require, module, exports) {
        "use strict";

        var _leaflet = require("./global/leaflet");

        var _leaflet2 = _interopRequireDefault(_leaflet);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {"default": obj};
        }

// In RMarkdown's self-contained mode, we don't have a way to carry around the
// images that Leaflet needs but doesn't load into the page. Instead, we'll use
// the unpkg CDN.
        if (typeof _leaflet2["default"].Icon.Default.imagePath === "undefined") {
          _leaflet2["default"].Icon.Default.imagePath = "https://unpkg.com/leaflet@1.3.1/dist/images/";
        }

      }, {"./global/leaflet": 10}],
      6: [function (require, module, exports) {
        "use strict";

        var _leaflet = require("./global/leaflet");

        var _leaflet2 = _interopRequireDefault(_leaflet);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {"default": obj};
        }

// add texxtsize, textOnly, and style
        _leaflet2["default"].Tooltip.prototype.options.textsize = "10px";
        _leaflet2["default"].Tooltip.prototype.options.textOnly = false;
        _leaflet2["default"].Tooltip.prototype.options.style = null; // copy original layout to not completely stomp it.

        var initLayoutOriginal = _leaflet2["default"].Tooltip.prototype._initLayout;

        _leaflet2["default"].Tooltip.prototype._initLayout = function () {
          initLayoutOriginal.call(this);
          this._container.style.fontSize = this.options.textsize;

          if (this.options.textOnly) {
            _leaflet2["default"].DomUtil.addClass(this._container,
                "leaflet-tooltip-text-only");
          }

          if (this.options.style) {
            for (var property in this.options.style) {
              this._container.style[property] = this.options.style[property];
            }
          }
        };

      }, {"./global/leaflet": 10}],
      7: [function (require, module, exports) {
        "use strict";

        var _leaflet = require("./global/leaflet");

        var _leaflet2 = _interopRequireDefault(_leaflet);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {"default": obj};
        }

        var protocolRegex = /^\/\//;

        var upgrade_protocol = function upgrade_protocol(urlTemplate) {
          if (protocolRegex.test(urlTemplate)) {
            if (window.location.protocol === "file:") {
              // if in a local file, support http
              // http should auto upgrade if necessary
              urlTemplate = "http:" + urlTemplate;
            }
          }

          return urlTemplate;
        };

        var originalLTileLayerInitialize = _leaflet2["default"].TileLayer.prototype.initialize;

        _leaflet2["default"].TileLayer.prototype.initialize = function (urlTemplate, options) {
          urlTemplate = upgrade_protocol(urlTemplate);
          originalLTileLayerInitialize.call(this, urlTemplate, options);
        };

        var originalLTileLayerWMSInitialize = _leaflet2["default"].TileLayer.WMS.prototype.initialize;

        _leaflet2["default"].TileLayer.WMS.prototype.initialize = function (urlTemplate,
            options) {
          urlTemplate = upgrade_protocol(urlTemplate);
          originalLTileLayerWMSInitialize.call(this, urlTemplate, options);
        };

      }, {"./global/leaflet": 10}],
      8: [function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports["default"] = global.HTMLWidgets;

          }).call(this)
        }).call(this,
            typeof global !== "undefined" ? global : typeof self !== "undefined" ? self
                : typeof window !== "undefined" ? window : {})
      }, {}],
      9: [function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports["default"] = global.jQuery;

          }).call(this)
        }).call(this,
            typeof global !== "undefined" ? global : typeof self !== "undefined" ? self
                : typeof window !== "undefined" ? window : {})
      }, {}],
      10: [function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports["default"] = global.L;

          }).call(this)
        }).call(this,
            typeof global !== "undefined" ? global : typeof self !== "undefined" ? self
                : typeof window !== "undefined" ? window : {})
      }, {}],
      11: [function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports["default"] = global.L.Proj;

          }).call(this)
        }).call(this,
            typeof global !== "undefined" ? global : typeof self !== "undefined" ? self
                : typeof window !== "undefined" ? window : {})
      }, {}],
      12: [function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports["default"] = global.Shiny;

          }).call(this)
        }).call(this,
            typeof global !== "undefined" ? global : typeof self !== "undefined" ? self
                : typeof window !== "undefined" ? window : {})
      }, {}],
      13: [function (require, module, exports) {
        "use strict";

        var _jquery = require("./global/jquery");

        var _jquery2 = _interopRequireDefault(_jquery);

        var _leaflet = require("./global/leaflet");

        var _leaflet2 = _interopRequireDefault(_leaflet);

        var _shiny = require("./global/shiny");

        var _shiny2 = _interopRequireDefault(_shiny);

        var _htmlwidgets = require("./global/htmlwidgets");

        var _htmlwidgets2 = _interopRequireDefault(_htmlwidgets);

        var _util = require("./util");

        var _crs_utils = require("./crs_utils");

        var _controlStore = require("./control-store");

        var _controlStore2 = _interopRequireDefault(_controlStore);

        var _layerManager = require("./layer-manager");

        var _layerManager2 = _interopRequireDefault(_layerManager);

        var _methods = require("./methods");

        var _methods2 = _interopRequireDefault(_methods);

        require("./fixup-default-icon");

        require("./fixup-default-tooltip");

        require("./fixup-url-protocol");

        var _dataframe = require("./dataframe");

        var _dataframe2 = _interopRequireDefault(_dataframe);

        var _clusterLayerStore = require("./cluster-layer-store");

        var _clusterLayerStore2 = _interopRequireDefault(_clusterLayerStore);

        function _interopRequireDefault(obj) {
          return obj && obj.__esModule ? obj : {"default": obj};
        }

        window.LeafletWidget = {};
        window.LeafletWidget.utils = {};

        var methods = window.LeafletWidget.methods = _jquery2["default"].extend({},
            _methods2["default"]);

        window.LeafletWidget.DataFrame = _dataframe2["default"];
        window.LeafletWidget.ClusterLayerStore = _clusterLayerStore2["default"];
        window.LeafletWidget.utils.getCRS = _crs_utils.getCRS; // Send updated bounds back to app. Takes a leaflet event object as input.

        function updateBounds(map) {
          var id = map.getContainer().id;
          var bounds = map.getBounds();

          _shiny2["default"].onInputChange(id + "_bounds", {
            north: bounds.getNorthEast().lat,
            east: bounds.getNorthEast().lng,
            south: bounds.getSouthWest().lat,
            west: bounds.getSouthWest().lng
          });

          _shiny2["default"].onInputChange(id + "_center", {
            lng: map.getCenter().lng,
            lat: map.getCenter().lat
          });

          _shiny2["default"].onInputChange(id + "_zoom", map.getZoom());
        }

        function preventUnintendedZoomOnScroll(map) {
          // Prevent unwanted scroll capturing. Similar in purpose to
          // https://github.com/CliffCloud/Leaflet.Sleep but with a
          // different set of heuristics.
          // The basic idea is that when a mousewheel/DOMMouseScroll
          // event is seen, we disable scroll wheel zooming until the
          // user moves their mouse cursor or clicks on the map. This
          // is slightly trickier than just listening for mousemove,
          // because mousemove is fired when the page is scrolled,
          // even if the user did not physically move the mouse. We
          // handle this by examining the mousemove event's screenX
          // and screenY properties; if they change, we know it's a
          // "true" move.
          // lastScreen can never be null, but its x and y can.
          var lastScreen = {
            x: null,
            y: null
          };
          (0, _jquery2["default"])(document).on("mousewheel DOMMouseScroll", "*",
              function (e) {
                // Disable zooming (until the mouse moves or click)
                map.scrollWheelZoom.disable(); // Any mousemove events at this screen position will be ignored.

                lastScreen = {
                  x: e.originalEvent.screenX,
                  y: e.originalEvent.screenY
                };
              });
          (0, _jquery2["default"])(document).on("mousemove", "*", function (e) {
            // Did the mouse really move?
            if (lastScreen.x !== null && e.screenX !== lastScreen.x || e.screenY
                !== lastScreen.y) {
              // It really moved. Enable zooming.
              map.scrollWheelZoom.enable();
              lastScreen = {
                x: null,
                y: null
              };
            }
          });
          (0, _jquery2["default"])(document).on("mousedown", ".leaflet", function (e) {
            // Clicking always enables zooming.
            map.scrollWheelZoom.enable();
            lastScreen = {
              x: null,
              y: null
            };
          });
        }

        _htmlwidgets2["default"].widget({
          name: "leaflet",
          type: "output",
          factory: function factory(el, width, height) {
            var map = null;
            return {
              // we need to store our map in our returned object.
              getMap: function getMap() {
                return map;
              },
              renderValue: function renderValue(data) {
                // Create an appropriate CRS Object if specified
                if (data && data.options && data.options.crs) {
                  data.options.crs = (0, _crs_utils.getCRS)(data.options.crs);
                } // As per https://github.com/rstudio/leaflet/pull/294#discussion_r79584810

                if (map) {
                  map.remove();

                  map = function () {

                  }(); // undefine map

                }

                if (data.options.mapFactory && typeof data.options.mapFactory
                    === "function") {
                  map = data.options.mapFactory(el, data.options);
                } else {
                  map = _leaflet2["default"].map(el, data.options);
                }

                preventUnintendedZoomOnScroll(map); // Store some state in the map object

                map.leafletr = {
                  // Has the map ever rendered successfully?
                  hasRendered: false,
                  // Data to be rendered when resize is called with area != 0
                  pendingRenderData: null
                }; // Check if the map is rendered statically (no output binding)

                if (_htmlwidgets2["default"].shinyMode && /\bshiny-bound-output\b/.test(
                    el.className)) {
                  map.id = el.id; // Store the map on the element so we can find it later by ID

                  (0, _jquery2["default"])(el).data("leaflet-map", map); // When the map is clicked, send the coordinates back to the app

                  map.on("click", function (e) {
                    _shiny2["default"].onInputChange(map.id + "_click", {
                      lat: e.latlng.lat,
                      lng: e.latlng.lng,
                      ".nonce": Math.random() // Force reactivity if lat/lng hasn't changed

                    });
                  });
                  var groupTimerId = null;
                  map.on("moveend", function (e) {
                    updateBounds(e.target);
                  }).on("layeradd layerremove", function (e) {
                    // If the layer that's coming or going is a group we created, tell
                    // the server.
                    if (map.layerManager.getGroupNameFromLayerGroup(e.layer)) {
                      // But to avoid chattiness, coalesce events
                      if (groupTimerId) {
                        clearTimeout(groupTimerId);
                        groupTimerId = null;
                      }

                      groupTimerId = setTimeout(function () {
                        groupTimerId = null;

                        _shiny2["default"].onInputChange(map.id + "_groups",
                            map.layerManager.getVisibleGroups());
                      }, 100);
                    }
                  });
                }

                this.doRenderValue(data, map);
              },
              doRenderValue: function doRenderValue(data, map) {
                // Leaflet does not behave well when you set up a bunch of layers when
                // the map is not visible (width/height == 0). Popups get misaligned
                // relative to their owning markers, and the fitBounds calculations
                // are off. Therefore we wait until the map is actually showing to
                // render the value (we rely on the resize() callback being invoked
                // at the appropriate time).
                if (el.offsetWidth === 0 || el.offsetHeight === 0) {
                  map.leafletr.pendingRenderData = data;
                  return;
                }

                map.leafletr.pendingRenderData = null; // Merge data options into defaults

                var options = _jquery2["default"].extend({
                  zoomToLimits: "always"
                }, data.options);

                if (!map.layerManager) {
                  map.controls = new _controlStore2["default"](map);
                  map.layerManager = new _layerManager2["default"](map);
                } else {
                  map.controls.clear();
                  map.layerManager.clear();
                }

                var explicitView = false;

                if (data.setView) {
                  explicitView = true;
                  map.setView.apply(map, data.setView);
                }

                if (data.fitBounds) {
                  explicitView = true;
                  methods.fitBounds.apply(map, data.fitBounds);
                }

                if (data.flyTo) {
                  if (!explicitView && !map.leafletr.hasRendered) {
                    // must be done to give a initial starting point
                    map.fitWorld();
                  }

                  explicitView = true;
                  map.flyTo.apply(map, data.flyTo);
                }

                if (data.flyToBounds) {
                  if (!explicitView && !map.leafletr.hasRendered) {
                    // must be done to give a initial starting point
                    map.fitWorld();
                  }

                  explicitView = true;
                  methods.flyToBounds.apply(map, data.flyToBounds);
                }

                if (data.options.center) {
                  explicitView = true;
                } // Returns true if the zoomToLimits option says that the map should be
                // zoomed to map elements.

                function needsZoom() {
                  return options.zoomToLimits === "always" || options.zoomToLimits
                      === "first"
                      && !map.leafletr.hasRendered;
                }

                if (!explicitView && needsZoom() && !map.getZoom()) {
                  if (data.limits && !_jquery2["default"].isEmptyObject(
                      data.limits)) {
                    // Use the natural limits of what's being drawn on the map
                    // If the size of the bounding box is 0, leaflet gets all weird
                    var pad = 0.006;

                    if (data.limits.lat[0] === data.limits.lat[1]) {
                      data.limits.lat[0] = data.limits.lat[0] - pad;
                      data.limits.lat[1] = data.limits.lat[1] + pad;
                    }

                    if (data.limits.lng[0] === data.limits.lng[1]) {
                      data.limits.lng[0] = data.limits.lng[0] - pad;
                      data.limits.lng[1] = data.limits.lng[1] + pad;
                    }

                    map.fitBounds([[data.limits.lat[0], data.limits.lng[0]],
                      [data.limits.lat[1], data.limits.lng[1]]]);
                  } else {
                    map.fitWorld();
                  }
                }

                for (var i = 0; data.calls && i < data.calls.length; i++) {
                  var call = data.calls[i];
                  if (methods[call.method]) {
                    methods[call.method].apply(map,
                        call.args);
                  } else {
                    (0, _util.log)(
                        "Unknown method " + call.method);
                  }
                }

                map.leafletr.hasRendered = true;

                if (_htmlwidgets2["default"].shinyMode) {
                  setTimeout(function () {
                    updateBounds(map);
                  }, 1);
                }
              },
              resize: function resize(width, height) {
                if (map) {
                  map.invalidateSize();

                  if (map.leafletr.pendingRenderData) {
                    this.doRenderValue(map.leafletr.pendingRenderData, map);
                  }
                }
              }
            };
          }
        });

        if (_htmlwidgets2["default"].shinyMode) {
          _shiny2["default"].addCustomMessageHandler("leaflet-calls", function (data) {
            var id = data.id;
            var el = document.getElementById(id);
            var map = el ? (0, _jquery2["default"])(el).data("leaflet-map") : null;

            if (!map) {
              (0, _util.log)("Couldn't find map with id " + id);
              return;
            } // If the map has not rendered, stash the proposed `leafletProxy()` calls
            // in `pendingRenderData.calls` to be run on display via `doRenderValue()`.
            // This is necessary if the map has not been rendered.
            // If new pendingRenderData is set via a new `leaflet()`, the previous calls will be discarded.

            if (!map.leafletr.hasRendered) {
              map.leafletr.pendingRenderData.calls = map.leafletr.pendingRenderData.calls.concat(
                  data.calls);
              return;
            }

            for (var i = 0; i < data.calls.length; i++) {
              var call = data.calls[i];
              var args = call.args;

              for (var _i = 0; _i < call.evals.length; _i++) {
                window.HTMLWidgets.evaluateStringMember(args, call.evals[_i]);
              }

              if (call.dependencies) {
                _shiny2["default"].renderDependencies(call.dependencies);
              }

              if (methods[call.method]) {
                methods[call.method].apply(map,
                    args);
              } else {
                (0, _util.log)(
                    "Unknown method " + call.method);
              }
            }
          });
        }

      }, {
        "./cluster-layer-store": 1,
        "./control-store": 2,
        "./crs_utils": 3,
        "./dataframe": 4,
        "./fixup-default-icon": 5,
        "./fixup-default-tooltip": 6,
        "./fixup-url-protocol": 7,
        "./global/htmlwidgets": 8,
        "./global/jquery": 9,
        "./global/leaflet": 10,
        "./global/shiny": 12,
        "./layer-manager": 14,
        "./methods": 15,
        "./util": 17
      }],
      14: [function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            Object.defineProperty(exports, "__esModule", {
              value: true
            });
            exports["default"] = undefined;

            var _jquery = require("./global/jquery");

            var _jquery2 = _interopRequireDefault(_jquery);

            var _leaflet = require("./global/leaflet");

            var _leaflet2 = _interopRequireDefault(_leaflet);

            var _util = require("./util");

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {"default": obj};
            }

            function _classCallCheck(instance, Constructor) {
              if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
              }
            }

            function _defineProperties(target, props) {
              for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) {
                  descriptor.writable = true;
                }
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }

            function _createClass(Constructor, protoProps, staticProps) {
              if (protoProps) {
                _defineProperties(Constructor.prototype, protoProps);
              }
              if (staticProps) {
                _defineProperties(Constructor, staticProps);
              }
              return Constructor;
            }

            var LayerManager = /*#__PURE__*/function () {
              function LayerManager(map) {
                _classCallCheck(this, LayerManager);

                this._map = map; // BEGIN layer indices
                // {<groupname>: {<stamp>: layer}}

                this._byGroup = {}; // {<categoryName>: {<stamp>: layer}}

                this._byCategory = {}; // {<categoryName_layerId>: layer}

                this._byLayerId = {}; // {<stamp>: {
                //             "group": <groupname>,
                //             "layerId": <layerId>,
                //             "category": <category>,
                //             "container": <container>
                //           }
                // }

                this._byStamp = {}; // {<crosstalkGroupName>: {<key>: [<stamp>, <stamp>, ...], ...}}

                this._byCrosstalkGroup = {}; // END layer indices
                // {<categoryName>: L.layerGroup}

                this._categoryContainers = {}; // {<groupName>: L.layerGroup}

                this._groupContainers = {};
              }

              _createClass(LayerManager, [{
                key: "addLayer",
                value: function addLayer(layer, category, layerId, group, ctGroup,
                    ctKey) {
                  var _this = this;

                  // Was a group provided?
                  var hasId = typeof layerId === "string";
                  var grouped = typeof group === "string";
                  var stamp = _leaflet2["default"].Util.stamp(layer) + ""; // This will be the default layer group to add the layer to.
                  // We may overwrite this let before using it (i.e. if a group is assigned).
                  // This one liner creates the _categoryContainers[category] entry if it
                  // doesn't already exist.

                  var container = this._categoryContainers[category] = this._categoryContainers[category]
                      || _leaflet2["default"].layerGroup().addTo(this._map);

                  var oldLayer = null;

                  if (hasId) {
                    // First, remove any layer with the same category and layerId
                    var prefixedLayerId = this._layerIdKey(category, layerId);

                    oldLayer = this._byLayerId[prefixedLayerId];

                    if (oldLayer) {
                      this._removeLayer(oldLayer);
                    } // Update layerId index

                    this._byLayerId[prefixedLayerId] = layer;
                  } // Update group index

                  if (grouped) {
                    this._byGroup[group] = this._byGroup[group] || {};
                    this._byGroup[group][stamp] = layer; // Since a group is assigned, don't add the layer to the category's layer
                    // group; instead, use the group's layer group.
                    // This one liner creates the _groupContainers[group] entry if it doesn't
                    // already exist.

                    container = this.getLayerGroup(group, true);
                  } // Update category index

                  this._byCategory[category] = this._byCategory[category] || {};
                  this._byCategory[category][stamp] = layer; // Update stamp index

                  var layerInfo = this._byStamp[stamp] = {
                    layer: layer,
                    group: group,
                    ctGroup: ctGroup,
                    ctKey: ctKey,
                    layerId: layerId,
                    category: category,
                    container: container,
                    hidden: false
                  }; // Update crosstalk group index

                  if (ctGroup) {
                    if (layer.setStyle) {
                      // Need to save this info so we know what to set opacity to later
                      layer.options.origOpacity = typeof layer.options.opacity
                      !== "undefined"
                          ? layer.options.opacity : 0.5;
                      layer.options.origFillOpacity = typeof layer.options.fillOpacity
                      !== "undefined"
                          ? layer.options.fillOpacity : 0.2;
                    }

                    var ctg = this._byCrosstalkGroup[ctGroup];

                    if (!ctg) {
                      ctg = this._byCrosstalkGroup[ctGroup] = {};
                      var crosstalk = global.crosstalk;

                      var handleFilter = function handleFilter(e) {
                        if (!e.value) {
                          var groupKeys = Object.keys(ctg);

                          for (var i = 0; i < groupKeys.length; i++) {
                            var key = groupKeys[i];
                            var _layerInfo = _this._byStamp[ctg[key]];

                            _this._setVisibility(_layerInfo, true);
                          }
                        } else {
                          var selectedKeys = {};

                          for (var _i = 0; _i < e.value.length; _i++) {
                            selectedKeys[e.value[_i]] = true;
                          }

                          var _groupKeys = Object.keys(ctg);

                          for (var _i2 = 0; _i2 < _groupKeys.length; _i2++) {
                            var _key = _groupKeys[_i2];
                            var _layerInfo2 = _this._byStamp[ctg[_key]];

                            _this._setVisibility(_layerInfo2,
                                selectedKeys[_groupKeys[_i2]]);
                          }
                        }
                      };

                      var filterHandle = new crosstalk.FilterHandle(ctGroup);
                      filterHandle.on("change", handleFilter);

                      var handleSelection = function handleSelection(e) {
                        if (!e.value || !e.value.length) {
                          var groupKeys = Object.keys(ctg);

                          for (var i = 0; i < groupKeys.length; i++) {
                            var key = groupKeys[i];
                            var _layerInfo3 = _this._byStamp[ctg[key]];

                            _this._setOpacity(_layerInfo3, 1.0);
                          }
                        } else {
                          var selectedKeys = {};

                          for (var _i3 = 0; _i3 < e.value.length; _i3++) {
                            selectedKeys[e.value[_i3]] = true;
                          }

                          var _groupKeys2 = Object.keys(ctg);

                          for (var _i4 = 0; _i4 < _groupKeys2.length; _i4++) {
                            var _key2 = _groupKeys2[_i4];
                            var _layerInfo4 = _this._byStamp[ctg[_key2]];

                            _this._setOpacity(_layerInfo4,
                                selectedKeys[_groupKeys2[_i4]] ? 1.0 : 0.2);
                          }
                        }
                      };

                      var selHandle = new crosstalk.SelectionHandle(ctGroup);
                      selHandle.on("change", handleSelection);
                      setTimeout(function () {
                        handleFilter({
                          value: filterHandle.filteredKeys
                        });
                        handleSelection({
                          value: selHandle.value
                        });
                      }, 100);
                    }

                    if (!ctg[ctKey]) {
                      ctg[ctKey] = [];
                    }
                    ctg[ctKey].push(stamp);
                  } // Add to container

                  if (!layerInfo.hidden) {
                    container.addLayer(layer);
                  }
                  return oldLayer;
                }
              }, {
                key: "brush",
                value: function brush(bounds, extraInfo) {
                  var _this2 = this;

                  /* eslint-disable no-console */
                  // For each Crosstalk group...
                  Object.keys(this._byCrosstalkGroup).forEach(function (ctGroupName) {
                    var ctg = _this2._byCrosstalkGroup[ctGroupName];
                    var selection = []; // ...iterate over each Crosstalk key (each of which may have multiple
                    // layers)...

                    Object.keys(ctg).forEach(function (ctKey) {
                      // ...and for each layer...
                      ctg[ctKey].forEach(function (stamp) {
                        var layerInfo = _this2._byStamp[stamp]; // ...if it's something with a point...

                        if (layerInfo.layer.getLatLng) {
                          // ... and it's inside the selection bounds...
                          // TODO: Use pixel containment, not lat/lng containment
                          if (bounds.contains(layerInfo.layer.getLatLng())) {
                            // ...add the key to the selection.
                            selection.push(ctKey);
                          }
                        }
                      });
                    });
                    new global.crosstalk.SelectionHandle(ctGroupName).set(selection,
                        extraInfo);
                  });
                }
              }, {
                key: "unbrush",
                value: function unbrush(extraInfo) {
                  Object.keys(this._byCrosstalkGroup).forEach(function (ctGroupName) {
                    new global.crosstalk.SelectionHandle(ctGroupName).clear(
                        extraInfo);
                  });
                }
              }, {
                key: "_setVisibility",
                value: function _setVisibility(layerInfo, visible) {
                  if (layerInfo.hidden ^ visible) {

                  } else if (visible) {
                    layerInfo.container.addLayer(layerInfo.layer);
                    layerInfo.hidden = false;
                  } else {
                    layerInfo.container.removeLayer(layerInfo.layer);
                    layerInfo.hidden = true;
                  }
                }
              }, {
                key: "_setOpacity",
                value: function _setOpacity(layerInfo, opacity) {
                  if (layerInfo.layer.setOpacity) {
                    layerInfo.layer.setOpacity(opacity);
                  } else if (layerInfo.layer.setStyle) {
                    layerInfo.layer.setStyle({
                      opacity: opacity * layerInfo.layer.options.origOpacity,
                      fillOpacity: opacity
                          * layerInfo.layer.options.origFillOpacity
                    });
                  }
                }
              }, {
                key: "getLayer",
                value: function getLayer(category, layerId) {
                  return this._byLayerId[this._layerIdKey(category, layerId)];
                }
              }, {
                key: "removeLayer",
                value: function removeLayer(category, layerIds) {
                  var _this3 = this;

                  // Find layer info
                  _jquery2["default"].each((0, _util.asArray)(layerIds),
                      function (i, layerId) {
                        var layer = _this3._byLayerId[_this3._layerIdKey(category,
                            layerId)];

                        if (layer) {
                          _this3._removeLayer(layer);
                        }
                      });
                }
              }, {
                key: "clearLayers",
                value: function clearLayers(category) {
                  var _this4 = this;

                  // Find all layers in _byCategory[category]
                  var catTable = this._byCategory[category];

                  if (!catTable) {
                    return false;
                  } // Remove all layers. Make copy of keys to avoid mutating the collection
                  // behind the iterator you're accessing.

                  var stamps = [];

                  _jquery2["default"].each(catTable, function (k, v) {
                    stamps.push(k);
                  });

                  _jquery2["default"].each(stamps, function (i, stamp) {
                    _this4._removeLayer(stamp);
                  });
                }
              }, {
                key: "getLayerGroup",
                value: function getLayerGroup(group, ensureExists) {
                  var g = this._groupContainers[group];

                  if (ensureExists && !g) {
                    this._byGroup[group] = this._byGroup[group] || {};
                    g = this._groupContainers[group] = _leaflet2["default"].featureGroup();
                    g.groupname = group;
                    g.addTo(this._map);
                  }

                  return g;
                }
              }, {
                key: "getGroupNameFromLayerGroup",
                value: function getGroupNameFromLayerGroup(layerGroup) {
                  return layerGroup.groupname;
                }
              }, {
                key: "getVisibleGroups",
                value: function getVisibleGroups() {
                  var _this5 = this;

                  var result = [];

                  _jquery2["default"].each(this._groupContainers, function (k, v) {
                    if (_this5._map.hasLayer(v)) {
                      result.push(k);
                    }
                  });

                  return result;
                }
              }, {
                key: "getAllGroupNames",
                value: function getAllGroupNames() {
                  var result = [];

                  _jquery2["default"].each(this._groupContainers, function (k, v) {
                    result.push(k);
                  });

                  return result;
                }
              }, {
                key: "clearGroup",
                value: function clearGroup(group) {
                  var _this6 = this;

                  // Find all layers in _byGroup[group]
                  var groupTable = this._byGroup[group];

                  if (!groupTable) {
                    return false;
                  } // Remove all layers. Make copy of keys to avoid mutating the collection
                  // behind the iterator you're accessing.

                  var stamps = [];

                  _jquery2["default"].each(groupTable, function (k, v) {
                    stamps.push(k);
                  });

                  _jquery2["default"].each(stamps, function (i, stamp) {
                    _this6._removeLayer(stamp);
                  });
                }
              }, {
                key: "clear",
                value: function clear() {
                  function clearLayerGroup(key, layerGroup) {
                    layerGroup.clearLayers();
                  } // Clear all indices and layerGroups

                  this._byGroup = {};
                  this._byCategory = {};
                  this._byLayerId = {};
                  this._byStamp = {};
                  this._byCrosstalkGroup = {};

                  _jquery2["default"].each(this._categoryContainers, clearLayerGroup);

                  this._categoryContainers = {};

                  _jquery2["default"].each(this._groupContainers, clearLayerGroup);

                  this._groupContainers = {};
                }
              }, {
                key: "_removeLayer",
                value: function _removeLayer(layer) {
                  var stamp;

                  if (typeof layer === "string") {
                    stamp = layer;
                  } else {
                    stamp = _leaflet2["default"].Util.stamp(layer);
                  }

                  var layerInfo = this._byStamp[stamp];

                  if (!layerInfo) {
                    return false;
                  }

                  layerInfo.container.removeLayer(stamp);

                  if (typeof layerInfo.group === "string") {
                    delete this._byGroup[layerInfo.group][stamp];
                  }

                  if (typeof layerInfo.layerId === "string") {
                    delete this._byLayerId[this._layerIdKey(layerInfo.category,
                        layerInfo.layerId)];
                  }

                  delete this._byCategory[layerInfo.category][stamp];
                  delete this._byStamp[stamp];

                  if (layerInfo.ctGroup) {
                    var ctGroup = this._byCrosstalkGroup[layerInfo.ctGroup];
                    var layersForKey = ctGroup[layerInfo.ctKey];
                    var idx = layersForKey ? layersForKey.indexOf(stamp) : -1;

                    if (idx >= 0) {
                      if (layersForKey.length === 1) {
                        delete ctGroup[layerInfo.ctKey];
                      } else {
                        layersForKey.splice(idx, 1);
                      }
                    }
                  }
                }
              }, {
                key: "_layerIdKey",
                value: function _layerIdKey(category, layerId) {
                  return category + "\n" + layerId;
                }
              }]);

              return LayerManager;
            }();

            exports["default"] = LayerManager;

          }).call(this)
        }).call(this,
            typeof global !== "undefined" ? global : typeof self !== "undefined" ? self
                : typeof window !== "undefined" ? window : {})
      }, {"./global/jquery": 9, "./global/leaflet": 10, "./util": 17}],
      15: [function (require, module, exports) {
        (function (global) {
          (function () {
            "use strict";

            Object.defineProperty(exports, "__esModule", {
              value: true
            });

            var _jquery = require("./global/jquery");

            var _jquery2 = _interopRequireDefault(_jquery);

            var _leaflet = require("./global/leaflet");

            var _leaflet2 = _interopRequireDefault(_leaflet);

            var _shiny = require("./global/shiny");

            var _shiny2 = _interopRequireDefault(_shiny);

            var _htmlwidgets = require("./global/htmlwidgets");

            var _htmlwidgets2 = _interopRequireDefault(_htmlwidgets);

            var _util = require("./util");

            var _crs_utils = require("./crs_utils");

            var _dataframe = require("./dataframe");

            var _dataframe2 = _interopRequireDefault(_dataframe);

            var _clusterLayerStore = require("./cluster-layer-store");

            var _clusterLayerStore2 = _interopRequireDefault(_clusterLayerStore);

            var _mipmapper = require("./mipmapper");

            var _mipmapper2 = _interopRequireDefault(_mipmapper);

            function _interopRequireDefault(obj) {
              return obj && obj.__esModule ? obj : {"default": obj};
            }

            var methods = {};
            exports["default"] = methods;

            function mouseHandler(mapId, layerId, group, eventName, extraInfo) {
              return function (e) {
                if (!_htmlwidgets2["default"].shinyMode) {
                  return;
                }
                var latLng = e.target.getLatLng ? e.target.getLatLng() : e.latlng;

                if (latLng) {
                  // retrieve only lat, lon values to remove prototype
                  //   and extra parameters added by 3rd party modules
                  // these objects are for json serialization, not javascript
                  var latLngVal = _leaflet2["default"].latLng(latLng); // make sure it has consistent shape

                  latLng = {
                    lat: latLngVal.lat,
                    lng: latLngVal.lng
                  };
                }

                var eventInfo = _jquery2["default"].extend({
                  id: layerId,
                  ".nonce": Math.random() // force reactivity

                }, group !== null ? {
                  group: group
                } : null, latLng, extraInfo);

                _shiny2["default"].onInputChange(mapId + "_" + eventName, eventInfo);
              };
            }

            methods.mouseHandler = mouseHandler;

            methods.clearGroup = function (group) {
              var _this = this;

              _jquery2["default"].each((0, _util.asArray)(group), function (i, v) {
                _this.layerManager.clearGroup(v);
              });
            };

            methods.setView = function (center, zoom, options) {
              this.setView(center, zoom, options);
            };

            methods.fitBounds = function (lat1, lng1, lat2, lng2, options) {
              this.fitBounds([[lat1, lng1], [lat2, lng2]], options);
            };

            methods.flyTo = function (center, zoom, options) {
              this.flyTo(center, zoom, options);
            };

            methods.flyToBounds = function (lat1, lng1, lat2, lng2, options) {
              this.flyToBounds([[lat1, lng1], [lat2, lng2]], options);
            };

            methods.setMaxBounds = function (lat1, lng1, lat2, lng2) {
              this.setMaxBounds([[lat1, lng1], [lat2, lng2]]);
            };

            methods.addPopups = function (lat, lng, popup, layerId, group, options) {
              var _this2 = this;

              var df = new _dataframe2["default"]().col("lat", lat).col("lng", lng).col(
                  "popup",
                  popup).col("layerId", layerId).col("group", group).cbind(options);

              var _loop = function _loop(i) {
                if (_jquery2["default"].isNumeric(df.get(i, "lat"))
                    && _jquery2["default"].isNumeric(
                        df.get(i, "lng"))) {
                  (function () {
                    var popup = _leaflet2["default"].popup(df.get(i)).setLatLng(
                        [df.get(i, "lat"), df.get(i, "lng")]).setContent(
                        df.get(i, "popup"));

                    var thisId = df.get(i, "layerId");
                    var thisGroup = df.get(i, "group");
                    this.layerManager.addLayer(popup, "popup", thisId, thisGroup);
                  }).call(_this2);
                }
              };

              for (var i = 0; i < df.nrow(); i++) {
                _loop(i);
              }
            };

            methods.removePopup = function (layerId) {
              this.layerManager.removeLayer("popup", layerId);
            };

            methods.clearPopups = function () {
              this.layerManager.clearLayers("popup");
            };

            methods.addTiles = function (urlTemplate, layerId, group, options) {
              this.layerManager.addLayer(
                  _leaflet2["default"].tileLayer(urlTemplate, options), "tile",
                  layerId, group);
            };

            methods.removeTiles = function (layerId) {
              this.layerManager.removeLayer("tile", layerId);
            };

            methods.clearTiles = function () {
              this.layerManager.clearLayers("tile");
            };

            methods.addWMSTiles = function (baseUrl, layerId, group, options) {
              if (options && options.crs) {
                options.crs = (0, _crs_utils.getCRS)(options.crs);
              }

              this.layerManager.addLayer(
                  _leaflet2["default"].tileLayer.wms(baseUrl, options), "tile",
                  layerId, group);
            }; // Given:
//   {data: ["a", "b", "c"], index: [0, 1, 0, 2]}
// returns:
//   ["a", "b", "a", "c"]

            function unpackStrings(iconset) {
              if (!iconset) {
                return iconset;
              }

              if (typeof iconset.index === "undefined") {
                return iconset;
              }

              iconset.data = (0, _util.asArray)(iconset.data);
              iconset.index = (0, _util.asArray)(iconset.index);
              return _jquery2["default"].map(iconset.index, function (e, i) {
                return iconset.data[e];
              });
            }

            function addMarkers(map, df, group, clusterOptions, clusterId, markerFunc) {
              (function () {
                var _this3 = this;

                var clusterGroup = this.layerManager.getLayer("cluster", clusterId),
                    cluster = clusterOptions !== null;

                if (cluster && !clusterGroup) {
                  clusterGroup = _leaflet2["default"].markerClusterGroup.layerSupport(
                      clusterOptions);

                  if (clusterOptions.freezeAtZoom) {
                    var freezeAtZoom = clusterOptions.freezeAtZoom;
                    delete clusterOptions.freezeAtZoom;
                    clusterGroup.freezeAtZoom(freezeAtZoom);
                  }

                  clusterGroup.clusterLayerStore = new _clusterLayerStore2["default"](
                      clusterGroup);
                }

                var extraInfo = cluster ? {
                  clusterId: clusterId
                } : {};

                var _loop2 = function _loop2(i) {
                  if (_jquery2["default"].isNumeric(df.get(i, "lat"))
                      && _jquery2["default"].isNumeric(df.get(i, "lng"))) {
                    (function () {
                      var marker = markerFunc(df, i);
                      var thisId = df.get(i, "layerId");
                      var thisGroup = cluster ? null : df.get(i, "group");

                      if (cluster) {
                        clusterGroup.clusterLayerStore.add(marker, thisId);
                      } else {
                        this.layerManager.addLayer(marker, "marker", thisId,
                            thisGroup,
                            df.get(i, "ctGroup", true),
                            df.get(i, "ctKey", true));
                      }

                      var popup = df.get(i, "popup");
                      var popupOptions = df.get(i, "popupOptions");

                      if (popup !== null) {
                        if (popupOptions !== null) {
                          marker.bindPopup(popup, popupOptions);
                        } else {
                          marker.bindPopup(popup);
                        }
                      }

                      var label = df.get(i, "label");
                      var labelOptions = df.get(i, "labelOptions");

                      if (label !== null) {
                        if (labelOptions !== null) {
                          if (labelOptions.permanent) {
                            marker.bindTooltip(label,
                                labelOptions).openTooltip();
                          } else {
                            marker.bindTooltip(label, labelOptions);
                          }
                        } else {
                          marker.bindTooltip(label);
                        }
                      }

                      marker.on("click",
                          mouseHandler(this.id, thisId, thisGroup, "marker_click",
                              extraInfo), this);
                      marker.on("mouseover",
                          mouseHandler(this.id, thisId, thisGroup,
                              "marker_mouseover", extraInfo),
                          this);
                      marker.on("mouseout",
                          mouseHandler(this.id, thisId, thisGroup,
                              "marker_mouseout", extraInfo),
                          this);
                      marker.on("dragend",
                          mouseHandler(this.id, thisId, thisGroup,
                              "marker_dragend", extraInfo),
                          this);
                    }).call(_this3);
                  }
                };

                for (var i = 0; i < df.nrow(); i++) {
                  _loop2(i);
                }

                if (cluster) {
                  this.layerManager.addLayer(clusterGroup, "cluster", clusterId,
                      group);
                }
              }).call(map);
            }

            methods.addGenericMarkers = addMarkers;

            methods.addMarkers = function (lat, lng, icon, layerId, group, options, popup,
                popupOptions, clusterOptions, clusterId, label, labelOptions,
                crosstalkOptions) {
              var icondf;
              var getIcon;

              if (icon) {
                // Unpack icons
                icon.iconUrl = unpackStrings(icon.iconUrl);
                icon.iconRetinaUrl = unpackStrings(icon.iconRetinaUrl);
                icon.shadowUrl = unpackStrings(icon.shadowUrl);
                icon.shadowRetinaUrl = unpackStrings(icon.shadowRetinaUrl); // This cbinds the icon URLs and any other icon options; they're all
                // present on the icon object.

                icondf = new _dataframe2["default"]().cbind(icon); // Constructs an icon from a specified row of the icon dataframe.

                getIcon = function getIcon(i) {
                  var opts = icondf.get(i);

                  if (!opts.iconUrl) {
                    return new _leaflet2["default"].Icon.Default();
                  } // Composite options (like points or sizes) are passed from R with each
                  // individual component as its own option. We need to combine them now
                  // into their composite form.

                  if (opts.iconWidth) {
                    opts.iconSize = [opts.iconWidth, opts.iconHeight];
                  }

                  if (opts.shadowWidth) {
                    opts.shadowSize = [opts.shadowWidth, opts.shadowHeight];
                  }

                  if (opts.iconAnchorX) {
                    opts.iconAnchor = [opts.iconAnchorX, opts.iconAnchorY];
                  }

                  if (opts.shadowAnchorX) {
                    opts.shadowAnchor = [opts.shadowAnchorX, opts.shadowAnchorY];
                  }

                  if (opts.popupAnchorX) {
                    opts.popupAnchor = [opts.popupAnchorX, opts.popupAnchorY];
                  }

                  return new _leaflet2["default"].Icon(opts);
                };
              }

              if (!(_jquery2["default"].isEmptyObject(lat)
                      || _jquery2["default"].isEmptyObject(lng))
                  || _jquery2["default"].isNumeric(lat) && _jquery2["default"].isNumeric(
                      lng)) {
                var df = new _dataframe2["default"]().col("lat", lat).col("lng",
                    lng).col("layerId",
                    layerId).col("group", group).col("popup", popup).col("popupOptions",
                    popupOptions).col("label", label).col("labelOptions",
                    labelOptions).cbind(
                    options).cbind(crosstalkOptions || {});
                if (icon) {
                  icondf.effectiveLength = df.nrow();
                }
                addMarkers(this, df, group, clusterOptions, clusterId,
                    function (df, i) {
                      var options = df.get(i);
                      if (icon) {
                        options.icon = getIcon(i);
                      }
                      return _leaflet2["default"].marker(
                          [df.get(i, "lat"), df.get(i, "lng")], options);
                    });
              }
            };

            methods.addAwesomeMarkers = function (lat, lng, icon, layerId, group, options,
                popup,
                popupOptions, clusterOptions, clusterId, label, labelOptions,
                crosstalkOptions) {
              var icondf;
              var getIcon;

              if (icon) {
                // This cbinds the icon URLs and any other icon options; they're all
                // present on the icon object.
                icondf = new _dataframe2["default"]().cbind(icon); // Constructs an icon from a specified row of the icon dataframe.

                getIcon = function getIcon(i) {
                  var opts = icondf.get(i);

                  if (!opts) {
                    return new _leaflet2["default"].AwesomeMarkers.icon();
                  }

                  if (opts.squareMarker) {
                    opts.className = "awesome-marker awesome-marker-square";
                  }

                  return new _leaflet2["default"].AwesomeMarkers.icon(opts);
                };
              }

              if (!(_jquery2["default"].isEmptyObject(lat)
                      || _jquery2["default"].isEmptyObject(lng))
                  || _jquery2["default"].isNumeric(lat) && _jquery2["default"].isNumeric(
                      lng)) {
                var df = new _dataframe2["default"]().col("lat", lat).col("lng",
                    lng).col("layerId",
                    layerId).col("group", group).col("popup", popup).col("popupOptions",
                    popupOptions).col("label", label).col("labelOptions",
                    labelOptions).cbind(
                    options).cbind(crosstalkOptions || {});
                if (icon) {
                  icondf.effectiveLength = df.nrow();
                }
                addMarkers(this, df, group, clusterOptions, clusterId,
                    function (df, i) {
                      var options = df.get(i);
                      if (icon) {
                        options.icon = getIcon(i);
                      }
                      return _leaflet2["default"].marker(
                          [df.get(i, "lat"), df.get(i, "lng")], options);
                    });
              }
            };

            function addLayers(map, category, df, layerFunc) {
              var _loop3 = function _loop3(i) {
                (function () {
                  var layer = layerFunc(df, i);

                  if (!_jquery2["default"].isEmptyObject(layer)) {
                    var thisId = df.get(i, "layerId");
                    var thisGroup = df.get(i, "group");
                    this.layerManager.addLayer(layer, category, thisId, thisGroup,
                        df.get(i, "ctGroup", true), df.get(i, "ctKey", true));

                    if (layer.bindPopup) {
                      var popup = df.get(i, "popup");
                      var popupOptions = df.get(i, "popupOptions");

                      if (popup !== null) {
                        if (popupOptions !== null) {
                          layer.bindPopup(popup, popupOptions);
                        } else {
                          layer.bindPopup(popup);
                        }
                      }
                    }

                    if (layer.bindTooltip) {
                      var label = df.get(i, "label");
                      var labelOptions = df.get(i, "labelOptions");

                      if (label !== null) {
                        if (labelOptions !== null) {
                          layer.bindTooltip(label, labelOptions);
                        } else {
                          layer.bindTooltip(label);
                        }
                      }
                    }

                    layer.on("click", mouseHandler(this.id, thisId, thisGroup,
                            category + "_click"),
                        this);
                    layer.on("mouseover",
                        mouseHandler(this.id, thisId, thisGroup,
                            category + "_mouseover"), this);
                    layer.on("mouseout",
                        mouseHandler(this.id, thisId, thisGroup,
                            category + "_mouseout"), this);
                    var highlightStyle = df.get(i, "highlightOptions");

                    if (!_jquery2["default"].isEmptyObject(highlightStyle)) {
                      var defaultStyle = {};

                      _jquery2["default"].each(highlightStyle, function (k, v) {
                        if (k != "bringToFront" && k != "sendToBack") {
                          if (df.get(i, k)) {
                            defaultStyle[k] = df.get(i, k);
                          }
                        }
                      });

                      layer.on("mouseover", function (e) {
                        this.setStyle(highlightStyle);

                        if (highlightStyle.bringToFront) {
                          this.bringToFront();
                        }
                      });
                      layer.on("mouseout", function (e) {
                        this.setStyle(defaultStyle);

                        if (highlightStyle.sendToBack) {
                          this.bringToBack();
                        }
                      });
                    }
                  }
                }).call(map);
              };

              for (var i = 0; i < df.nrow(); i++) {
                _loop3(i);
              }
            }

            methods.addGenericLayers = addLayers;

            methods.addCircles = function (lat, lng, radius, layerId, group, options, popup,
                popupOptions, label, labelOptions, highlightOptions, crosstalkOptions) {
              if (!(_jquery2["default"].isEmptyObject(lat)
                      || _jquery2["default"].isEmptyObject(lng))
                  || _jquery2["default"].isNumeric(lat) && _jquery2["default"].isNumeric(
                      lng)) {
                var df = new _dataframe2["default"]().col("lat", lat).col("lng",
                    lng).col("radius",
                    radius).col("layerId", layerId).col("group", group).col("popup",
                    popup).col(
                    "popupOptions", popupOptions).col("label", label).col(
                    "labelOptions",
                    labelOptions).col("highlightOptions", highlightOptions).cbind(
                    options).cbind(
                    crosstalkOptions || {});
                addLayers(this, "shape", df, function (df, i) {
                  if (_jquery2["default"].isNumeric(df.get(i, "lat"))
                      && _jquery2["default"].isNumeric(df.get(i, "lng"))
                      && _jquery2["default"].isNumeric(df.get(i, "radius"))) {
                    return _leaflet2["default"].circle(
                        [df.get(i, "lat"), df.get(i, "lng")],
                        df.get(i, "radius"), df.get(i));
                  } else {
                    return null;
                  }
                });
              }
            };

            methods.addCircleMarkers = function (lat, lng, radius, layerId, group, options,
                clusterOptions, clusterId, popup, popupOptions, label, labelOptions,
                crosstalkOptions) {
              if (!(_jquery2["default"].isEmptyObject(lat)
                      || _jquery2["default"].isEmptyObject(lng))
                  || _jquery2["default"].isNumeric(lat) && _jquery2["default"].isNumeric(
                      lng)) {
                var df = new _dataframe2["default"]().col("lat", lat).col("lng",
                    lng).col("radius",
                    radius).col("layerId", layerId).col("group", group).col("popup",
                    popup).col(
                    "popupOptions", popupOptions).col("label", label).col(
                    "labelOptions",
                    labelOptions).cbind(crosstalkOptions || {}).cbind(options);
                addMarkers(this, df, group, clusterOptions, clusterId,
                    function (df, i) {
                      return _leaflet2["default"].circleMarker(
                          [df.get(i, "lat"), df.get(i, "lng")],
                          df.get(i));
                    });
              }
            };
            /*
 * @param lat Array of arrays of latitude coordinates for polylines
 * @param lng Array of arrays of longitude coordinates for polylines
 */

            methods.addPolylines = function (polygons, layerId, group, options, popup,
                popupOptions,
                label, labelOptions, highlightOptions) {
              if (polygons.length > 0) {
                var df = new _dataframe2["default"]().col("shapes", polygons).col(
                    "layerId",
                    layerId).col("group", group).col("popup", popup).col("popupOptions",
                    popupOptions).col("label", label).col("labelOptions",
                    labelOptions).col(
                    "highlightOptions", highlightOptions).cbind(options);
                addLayers(this, "shape", df, function (df, i) {
                  var shapes = df.get(i, "shapes");
                  shapes = shapes.map(function (shape) {
                    return _htmlwidgets2["default"].dataframeToD3(shape[0]);
                  });

                  if (shapes.length > 1) {
                    return _leaflet2["default"].polyline(shapes, df.get(i));
                  } else {
                    return _leaflet2["default"].polyline(shapes[0], df.get(i));
                  }
                });
              }
            };

            methods.removeMarker = function (layerId) {
              this.layerManager.removeLayer("marker", layerId);
            };

            methods.clearMarkers = function () {
              this.layerManager.clearLayers("marker");
            };

            methods.removeMarkerCluster = function (layerId) {
              this.layerManager.removeLayer("cluster", layerId);
            };

            methods.removeMarkerFromCluster = function (layerId, clusterId) {
              var cluster = this.layerManager.getLayer("cluster", clusterId);
              if (!cluster) {
                return;
              }
              cluster.clusterLayerStore.remove(layerId);
            };

            methods.clearMarkerClusters = function () {
              this.layerManager.clearLayers("cluster");
            };

            methods.removeShape = function (layerId) {
              this.layerManager.removeLayer("shape", layerId);
            };

            methods.clearShapes = function () {
              this.layerManager.clearLayers("shape");
            };

            methods.addRectangles = function (lat1, lng1, lat2, lng2, layerId, group,
                options, popup,
                popupOptions, label, labelOptions, highlightOptions) {
              var df = new _dataframe2["default"]().col("lat1", lat1).col("lng1",
                  lng1).col("lat2",
                  lat2).col("lng2", lng2).col("layerId", layerId).col("group", group).col(
                  "popup",
                  popup).col("popupOptions", popupOptions).col("label", label).col(
                  "labelOptions",
                  labelOptions).col("highlightOptions", highlightOptions).cbind(options);
              addLayers(this, "shape", df, function (df, i) {
                if (_jquery2["default"].isNumeric(df.get(i, "lat1"))
                    && _jquery2["default"].isNumeric(
                        df.get(i, "lng1")) && _jquery2["default"].isNumeric(
                        df.get(i, "lat2"))
                    && _jquery2["default"].isNumeric(df.get(i, "lng2"))) {
                  return _leaflet2["default"].rectangle(
                      [[df.get(i, "lat1"), df.get(i, "lng1")],
                        [df.get(i, "lat2"), df.get(i, "lng2")]], df.get(i));
                } else {
                  return null;
                }
              });
            };
            /*
 * @param lat Array of arrays of latitude coordinates for polygons
 * @param lng Array of arrays of longitude coordinates for polygons
 */

            methods.addPolygons = function (polygons, layerId, group, options, popup,
                popupOptions,
                label, labelOptions, highlightOptions) {
              if (polygons.length > 0) {
                var df = new _dataframe2["default"]().col("shapes", polygons).col(
                    "layerId",
                    layerId).col("group", group).col("popup", popup).col("popupOptions",
                    popupOptions).col("label", label).col("labelOptions",
                    labelOptions).col(
                    "highlightOptions", highlightOptions).cbind(options);
                addLayers(this, "shape", df, function (df, i) {
                  // This code used to use L.multiPolygon, but that caused
                  // double-click on a multipolygon to fail to zoom in on the
                  // map. Surprisingly, putting all the rings in a single
                  // polygon seems to still work; complicated multipolygons
                  // are still rendered correctly.
                  var shapes = df.get(i, "shapes").map(function (polygon) {
                    return polygon.map(_htmlwidgets2["default"].dataframeToD3);
                  }).reduce(function (acc, val) {
                    return acc.concat(val);
                  }, []);
                  return _leaflet2["default"].polygon(shapes, df.get(i));
                });
              }
            };

            methods.addGeoJSON = function (data, layerId, group, style) {
              // This time, self is actually needed because the callbacks below need
              // to access both the inner and outer senses of "this"
              var self = this;

              if (typeof data === "string") {
                data = JSON.parse(data);
              }

              var globalStyle = _jquery2["default"].extend({}, style, data.style || {});

              var gjlayer = _leaflet2["default"].geoJson(data, {
                style: function style(feature) {
                  if (feature.style || feature.properties.style) {
                    return _jquery2["default"].extend({}, globalStyle,
                        feature.style,
                        feature.properties.style);
                  } else {
                    return globalStyle;
                  }
                },
                onEachFeature: function onEachFeature(feature, layer) {
                  var extraInfo = {
                    featureId: feature.id,
                    properties: feature.properties
                  };
                  var popup = feature.properties ? feature.properties.popup : null;
                  if (typeof popup !== "undefined" && popup !== null) {
                    layer.bindPopup(
                        popup);
                  }
                  layer.on("click",
                      mouseHandler(self.id, layerId, group, "geojson_click",
                          extraInfo),
                      this);
                  layer.on("mouseover",
                      mouseHandler(self.id, layerId, group, "geojson_mouseover",
                          extraInfo), this);
                  layer.on("mouseout",
                      mouseHandler(self.id, layerId, group, "geojson_mouseout",
                          extraInfo), this);
                }
              });

              this.layerManager.addLayer(gjlayer, "geojson", layerId, group);
            };

            methods.removeGeoJSON = function (layerId) {
              this.layerManager.removeLayer("geojson", layerId);
            };

            methods.clearGeoJSON = function () {
              this.layerManager.clearLayers("geojson");
            };

            methods.addTopoJSON = function (data, layerId, group, style) {
              // This time, self is actually needed because the callbacks below need
              // to access both the inner and outer senses of "this"
              var self = this;

              if (typeof data === "string") {
                data = JSON.parse(data);
              }

              var globalStyle = _jquery2["default"].extend({}, style, data.style || {});

              var gjlayer = _leaflet2["default"].geoJson(null, {
                style: function style(feature) {
                  if (feature.style || feature.properties.style) {
                    return _jquery2["default"].extend({}, globalStyle,
                        feature.style,
                        feature.properties.style);
                  } else {
                    return globalStyle;
                  }
                },
                onEachFeature: function onEachFeature(feature, layer) {
                  var extraInfo = {
                    featureId: feature.id,
                    properties: feature.properties
                  };
                  var popup = feature.properties.popup;
                  if (typeof popup !== "undefined" && popup !== null) {
                    layer.bindPopup(
                        popup);
                  }
                  layer.on("click",
                      mouseHandler(self.id, layerId, group, "topojson_click",
                          extraInfo), this);
                  layer.on("mouseover",
                      mouseHandler(self.id, layerId, group, "topojson_mouseover",
                          extraInfo), this);
                  layer.on("mouseout",
                      mouseHandler(self.id, layerId, group, "topojson_mouseout",
                          extraInfo), this);
                }
              });

              global.omnivore.topojson.parse(data, null, gjlayer);
              this.layerManager.addLayer(gjlayer, "topojson", layerId, group);
            };

            methods.removeTopoJSON = function (layerId) {
              this.layerManager.removeLayer("topojson", layerId);
            };

            methods.clearTopoJSON = function () {
              this.layerManager.clearLayers("topojson");
            };

            methods.addControl = function (html, position, layerId, classes) {
              function onAdd(map) {
                var div = _leaflet2["default"].DomUtil.create("div", classes);

                if (typeof layerId !== "undefined" && layerId !== null) {
                  div.setAttribute("id", layerId);
                }

                this._div = div; // It's possible for window.Shiny to be true but Shiny.initializeInputs to
                // not be, when a static leaflet widget is included as part of the shiny
                // UI directly (not through leafletOutput or uiOutput). In this case we
                // don't do the normal Shiny stuff as that will all happen when Shiny
                // itself loads and binds the entire doc.

                if (window.Shiny && _shiny2["default"].initializeInputs) {
                  _shiny2["default"].renderHtml(html, this._div);

                  _shiny2["default"].initializeInputs(this._div);

                  _shiny2["default"].bindAll(this._div);
                } else {
                  this._div.innerHTML = html;
                }

                return this._div;
              }

              function onRemove(map) {
                if (window.Shiny && _shiny2["default"].unbindAll) {
                  _shiny2["default"].unbindAll(this._div);
                }
              }

              var Control = _leaflet2["default"].Control.extend({
                options: {
                  position: position
                },
                onAdd: onAdd,
                onRemove: onRemove
              });

              this.controls.add(new Control(), layerId, html);
            };

            methods.addCustomControl = function (control, layerId) {
              this.controls.add(control, layerId);
            };

            methods.removeControl = function (layerId) {
              this.controls.remove(layerId);
            };

            methods.getControl = function (layerId) {
              this.controls.get(layerId);
            };

            methods.clearControls = function () {
              this.controls.clear();
            };

            methods.addLegend = function (options) {
              var legend = _leaflet2["default"].control({
                position: options.position
              });

              var gradSpan;

              legend.onAdd = function (map) {
                var div = _leaflet2["default"].DomUtil.create("div", options.className),
                    colors = options.colors,
                    labels = options.labels,
                    legendHTML = "";

                if (options.type === "numeric") {
                  // # Formatting constants.
                  var singleBinHeight = 20; // The distance between tick marks, in px

                  var vMargin = 8; // If 1st tick mark starts at top of gradient, how
                  // many extra px are needed for the top half of the
                  // 1st label? (ditto for last tick mark/label)

                  var tickWidth = 4; // How wide should tick marks be, in px?

                  var labelPadding = 6; // How much distance to reserve for tick mark?
                  // (Must be >= tickWidth)
                  // # Derived formatting parameters.
                  // What's the height of a single bin, in percentage (of gradient height)?
                  // It might not just be 1/(n-1), if the gradient extends past the tick
                  // marks (which can be the case for pretty cut points).

                  var singleBinPct = (options.extra.p_n - options.extra.p_1)
                      / (labels.length - 1); // Each bin is `singleBinHeight` high. How tall is the gradient?

                  var totalHeight = 1 / singleBinPct * singleBinHeight + 1; // How far should the first tick be shifted down, relative to the top
                  // of the gradient?

                  var tickOffset = singleBinHeight / singleBinPct * options.extra.p_1;
                  gradSpan = (0, _jquery2["default"])("<span/>").css({
                    "background": "linear-gradient(" + colors + ")",
                    "opacity": options.opacity,
                    "height": totalHeight + "px",
                    "width": "18px",
                    "display": "block",
                    "margin-top": vMargin + "px"
                  });
                  var leftDiv = (0, _jquery2["default"])("<div/>").css("float",
                          "left"),
                      rightDiv = (0, _jquery2["default"])("<div/>").css("float",
                          "left");
                  leftDiv.append(gradSpan);
                  (0, _jquery2["default"])(div).append(leftDiv).append(
                      rightDiv).append(
                      (0, _jquery2["default"])("<br>")); // Have to attach the div to the body at this early point, so that the
                  // svg text getComputedTextLength() actually works, below.

                  document.body.appendChild(div);
                  var ns = "http://www.w3.org/2000/svg";
                  var svg = document.createElementNS(ns, "svg");
                  rightDiv.append(svg);
                  var g = document.createElementNS(ns, "g");
                  (0, _jquery2["default"])(g).attr("transform",
                      "translate(0, " + vMargin + ")");
                  svg.appendChild(g); // max label width needed to set width of svg, and right-justify text

                  var maxLblWidth = 0; // Create tick marks and labels

                  _jquery2["default"].each(labels, function (i, label) {
                    var y = tickOffset + i * singleBinHeight + 0.5;
                    var thisLabel = document.createElementNS(ns, "text");
                    (0, _jquery2["default"])(thisLabel).text(labels[i]).attr("y",
                        y).attr("dx",
                        labelPadding).attr("dy", "0.5ex");
                    g.appendChild(thisLabel);
                    maxLblWidth = Math.max(maxLblWidth,
                        thisLabel.getComputedTextLength());
                    var thisTick = document.createElementNS(ns, "line");
                    (0, _jquery2["default"])(thisTick).attr("x1", 0).attr("x2",
                        tickWidth).attr("y1",
                        y).attr("y2", y).attr("stroke-width", 1);
                    g.appendChild(thisTick);
                  }); // Now that we know the max label width, we can right-justify

                  (0, _jquery2["default"])(svg).find("text").attr("dx",
                      labelPadding + maxLblWidth).attr("text-anchor", "end"); // Final size for <svg>

                  (0, _jquery2["default"])(svg).css({
                    width: maxLblWidth + labelPadding + "px",
                    height: totalHeight + vMargin * 2 + "px"
                  });

                  if (options.na_color && _jquery2["default"].inArray(
                      options.na_label, labels) < 0) {
                    (0, _jquery2["default"])(div).append(
                        "<div><i style=\"" + "background:" + options.na_color
                        + ";opacity:"
                        + options.opacity + ";margin-right:" + labelPadding + "px"
                        + ";\"></i>"
                        + options.na_label + "</div>");
                  }
                } else {
                  if (options.na_color && _jquery2["default"].inArray(
                      options.na_label, labels) < 0) {
                    colors.push(options.na_color);
                    labels.push(options.na_label);
                  }

                  for (var i = 0; i < colors.length; i++) {
                    legendHTML += "<i style=\"background:" + colors[i] + ";opacity:"
                        + options.opacity
                        + "\"></i> " + labels[i] + "<br>";
                  }

                  div.innerHTML = legendHTML;
                }

                if (options.title) {
                  (0, _jquery2["default"])(div).prepend(
                      "<div style=\"margin-bottom:3px\"><strong>" + options.title
                      + "</strong></div>");
                }
                return div;
              };

              if (options.group) {
                // Auto generate a layerID if not provided
                if (!options.layerId) {
                  options.layerId = _leaflet2["default"].Util.stamp(legend);
                }

                var map = this;
                map.on("overlayadd", function (e) {
                  if (e.name === options.group) {
                    map.controls.add(legend, options.layerId);
                  }
                });
                map.on("overlayremove", function (e) {
                  if (e.name === options.group) {
                    map.controls.remove(options.layerId);
                  }
                });
                map.on("groupadd", function (e) {
                  if (e.name === options.group) {
                    map.controls.add(legend, options.layerId);
                  }
                });
                map.on("groupremove", function (e) {
                  if (e.name === options.group) {
                    map.controls.remove(options.layerId);
                  }
                });
              }

              this.controls.add(legend, options.layerId);
            };

            methods.addLayersControl = function (baseGroups, overlayGroups, options) {
              var _this4 = this;

              // Only allow one layers control at a time
              methods.removeLayersControl.call(this);
              var firstLayer = true;
              var base = {};

              _jquery2["default"].each((0, _util.asArray)(baseGroups), function (i, g) {
                var layer = _this4.layerManager.getLayerGroup(g, true);

                if (layer) {
                  base[g] = layer; // Check if >1 base layers are visible; if so, hide all but the first one

                  if (_this4.hasLayer(layer)) {
                    if (firstLayer) {
                      firstLayer = false;
                    } else {
                      _this4.removeLayer(layer);
                    }
                  }
                }
              });

              var overlay = {};

              _jquery2["default"].each((0, _util.asArray)(overlayGroups),
                  function (i, g) {
                    var layer = _this4.layerManager.getLayerGroup(g, true);

                    if (layer) {
                      overlay[g] = layer;
                    }
                  });

              this.currentLayersControl = _leaflet2["default"].control.layers(base,
                  overlay, options);
              this.addControl(this.currentLayersControl);
            };

            methods.removeLayersControl = function () {
              if (this.currentLayersControl) {
                this.removeControl(this.currentLayersControl);
                this.currentLayersControl = null;
              }
            };

            methods.addScaleBar = function (options) {
              // Only allow one scale bar at a time
              methods.removeScaleBar.call(this);

              var scaleBar = _leaflet2["default"].control.scale(options).addTo(this);

              this.currentScaleBar = scaleBar;
            };

            methods.removeScaleBar = function () {
              if (this.currentScaleBar) {
                this.currentScaleBar.remove();
                this.currentScaleBar = null;
              }
            };

            methods.hideGroup = function (group) {
              var _this5 = this;

              _jquery2["default"].each((0, _util.asArray)(group), function (i, g) {
                var layer = _this5.layerManager.getLayerGroup(g, true);

                if (layer) {
                  _this5.removeLayer(layer);
                }
              });
            };

            methods.showGroup = function (group) {
              var _this6 = this;

              _jquery2["default"].each((0, _util.asArray)(group), function (i, g) {
                var layer = _this6.layerManager.getLayerGroup(g, true);

                if (layer) {
                  _this6.addLayer(layer);
                }
              });
            };

            function setupShowHideGroupsOnZoom(map) {
              if (map.leafletr._hasInitializedShowHideGroups) {
                return;
              }

              map.leafletr._hasInitializedShowHideGroups = true;

              function setVisibility(layer, visible, group) {
                if (visible !== map.hasLayer(layer)) {
                  if (visible) {
                    map.addLayer(layer);
                    map.fire("groupadd", {
                      "name": group,
                      "layer": layer
                    });
                  } else {
                    map.removeLayer(layer);
                    map.fire("groupremove", {
                      "name": group,
                      "layer": layer
                    });
                  }
                }
              }

              function showHideGroupsOnZoom() {
                if (!map.layerManager) {
                  return;
                }
                var zoom = map.getZoom();
                map.layerManager.getAllGroupNames().forEach(function (group) {
                  var layer = map.layerManager.getLayerGroup(group, false);

                  if (layer && typeof layer.zoomLevels !== "undefined") {
                    setVisibility(layer,
                        layer.zoomLevels === true || layer.zoomLevels.indexOf(zoom)
                        >= 0, group);
                  }
                });
              }

              map.showHideGroupsOnZoom = showHideGroupsOnZoom;
              map.on("zoomend", showHideGroupsOnZoom);
            }

            methods.setGroupOptions = function (group, options) {
              var _this7 = this;

              _jquery2["default"].each((0, _util.asArray)(group), function (i, g) {
                var layer = _this7.layerManager.getLayerGroup(g, true); // This slightly tortured check is because 0 is a valid value for zoomLevels

                if (typeof options.zoomLevels !== "undefined" && options.zoomLevels
                    !== null) {
                  layer.zoomLevels = (0, _util.asArray)(options.zoomLevels);
                }
              });

              setupShowHideGroupsOnZoom(this);
              this.showHideGroupsOnZoom();
            };

            methods.addRasterImage = function (uri, bounds, opacity, attribution, layerId,
                group) {
              // uri is a data URI containing an image. We want to paint this image as a
              // layer at (top-left) bounds[0] to (bottom-right) bounds[1].
              // We can't simply use ImageOverlay, as it uses bilinear scaling which looks
              // awful as you zoom in (and sometimes shifts positions or disappears).
              // Instead, we'll use a TileLayer.Canvas to draw pieces of the image.
              // First, some helper functions.
              // degree2tile converts latitude, longitude, and zoom to x and y tile
              // numbers. The tile numbers returned can be non-integral, as there's no
              // reason to expect that the lat/lng inputs are exactly on the border of two
              // tiles.
              //
              // We'll use this to convert the bounds we got from the server, into coords
              // in tile-space at a given zoom level. Note that once we do the conversion,
              // we don't to do any more trigonometry to convert between pixel coordinates
              // and tile coordinates; the source image pixel coords, destination canvas
              // pixel coords, and tile coords all can be scaled linearly.
              function degree2tile(lat, lng, zoom) {
                // See http://wiki.openstreetmap.org/wiki/Slippy_map_tilenames
                var latRad = lat * Math.PI / 180;
                var n = Math.pow(2, zoom);
                var x = (lng + 180) / 360 * n;
                var y = (1 - Math.log(Math.tan(latRad) + 1 / Math.cos(latRad))
                    / Math.PI) / 2 * n;
                return {
                  x: x,
                  y: y
                };
              } // Given a range [from,to) and either one or two numbers, returns true if
              // there is any overlap between [x,x1) and the range--or if x1 is omitted,
              // then returns true if x is within [from,to).

              function overlap(from, to, x,
                  /* optional */
                  x1) {
                if (arguments.length == 3) {
                  x1 = x;
                }
                return x < to && x1 >= from;
              }

              function getCanvasSmoothingProperty(ctx) {
                var candidates = ["imageSmoothingEnabled", "mozImageSmoothingEnabled",
                  "webkitImageSmoothingEnabled", "msImageSmoothingEnabled"];

                for (var i = 0; i < candidates.length; i++) {
                  if (typeof ctx[candidates[i]] !== "undefined") {
                    return candidates[i];
                  }
                }

                return null;
              } // Our general strategy is to:
              // 1. Load the data URI in an Image() object, so we can get its pixel
              //    dimensions and the underlying image data. (We could have done this
              //    by not encoding as PNG at all but just send an array of RGBA values
              //    from the server, but that would inflate the JSON too much.)
              // 2. Create a hidden canvas that we use just to extract the image data
              //    from the Image (using Context2D.getImageData()).
              // 3. Create a TileLayer.Canvas and add it to the map.
              // We want to synchronously create and attach the TileLayer.Canvas (so an
              // immediate call to clearRasters() will be respected, for example), but
              // Image loads its data asynchronously. Fortunately we can resolve this
              // by putting TileLayer.Canvas into async mode, which will let us create
              // and attach the layer but have it wait until the image is loaded before
              // it actually draws anything.
              // These are the variables that we will populate once the image is loaded.

              var imgData = null; // 1d row-major array, four [0-255] integers per pixel

              var imgDataMipMapper = null;
              var w = null; // image width in pixels

              var h = null; // image height in pixels
              // We'll use this array to store callbacks that need to be invoked once
              // imgData, w, and h have been resolved.

              var imgDataCallbacks = []; // Consumers of imgData, w, and h can call this to be notified when data
              // is available.

              function getImageData(callback) {
                if (imgData != null) {
                  // Must not invoke the callback immediately; it's too confusing and
                  // fragile to have a function invoke the callback *either* immediately
                  // or in the future. Better to be consistent here.
                  setTimeout(function () {
                    callback(imgData, w, h, imgDataMipMapper);
                  }, 0);
                } else {
                  imgDataCallbacks.push(callback);
                }
              }

              var img = new Image();

              img.onload = function () {
                // Save size
                w = img.width;
                h = img.height; // Create a dummy canvas to extract the image data

                var imgDataCanvas = document.createElement("canvas");
                imgDataCanvas.width = w;
                imgDataCanvas.height = h;
                imgDataCanvas.style.display = "none";
                document.body.appendChild(imgDataCanvas);
                var imgDataCtx = imgDataCanvas.getContext("2d");
                imgDataCtx.drawImage(img, 0, 0); // Save the image data.

                imgData = imgDataCtx.getImageData(0, 0, w, h).data;
                imgDataMipMapper = new _mipmapper2["default"](img); // Done with the canvas, remove it from the page so it can be gc'd.

                document.body.removeChild(imgDataCanvas); // Alert any getImageData callers who are waiting.

                for (var i = 0; i < imgDataCallbacks.length; i++) {
                  imgDataCallbacks[i](imgData, w, h, imgDataMipMapper);
                }

                imgDataCallbacks = [];
              };

              img.src = uri;

              var canvasTiles = _leaflet2["default"].gridLayer({
                opacity: opacity,
                attribution: attribution,
                detectRetina: true,
                async: true
              }); // NOTE: The done() function MUST NOT be invoked until after the current
              // tick; done() looks in Leaflet's tile cache for the current tile, and
              // since it's still being constructed, it won't be found.

              canvasTiles.createTile = function (tilePoint, done) {
                var zoom = tilePoint.z;

                var canvas = _leaflet2["default"].DomUtil.create("canvas");

                var error; // setup tile width and height according to the options

                var size = this.getTileSize();
                canvas.width = size.x;
                canvas.height = size.y;
                getImageData(function (imgData, w, h, mipmapper) {
                  try {
                    // The Context2D we'll being drawing onto. It's always 256x256.
                    var ctx = canvas.getContext("2d"); // Convert our image data's top-left and bottom-right locations into
                    // x/y tile coordinates. This is essentially doing a spherical mercator
                    // projection, then multiplying by 2^zoom.

                    var topLeft = degree2tile(bounds[0][0], bounds[0][1], zoom);
                    var bottomRight = degree2tile(bounds[1][0], bounds[1][1], zoom); // The size of the image in x/y tile coordinates.

                    var extent = {
                      x: bottomRight.x - topLeft.x,
                      y: bottomRight.y - topLeft.y
                    }; // Short circuit if tile is totally disjoint from image.

                    if (!overlap(tilePoint.x, tilePoint.x + 1, topLeft.x,
                        bottomRight.x)) {
                      return;
                    }
                    if (!overlap(tilePoint.y, tilePoint.y + 1, topLeft.y,
                        bottomRight.y)) {
                      return;
                    } // The linear resolution of the tile we're drawing is always 256px per tile unit.
                    // If the linear resolution (in either direction) of the image is less than 256px
                    // per tile unit, then use nearest neighbor; otherwise, use the canvas's built-in
                    // scaling.

                    var imgRes = {
                      x: w / extent.x,
                      y: h / extent.y
                    }; // We can do the actual drawing in one of three ways:
                    // - Call drawImage(). This is easy and fast, and results in smooth
                    //   interpolation (bilinear?). This is what we want when we are
                    //   reducing the image from its native size.
                    // - Call drawImage() with imageSmoothingEnabled=false. This is easy
                    //   and fast and gives us nearest-neighbor interpolation, which is what
                    //   we want when enlarging the image. However, it's unsupported on many
                    //   browsers (including QtWebkit).
                    // - Do a manual nearest-neighbor interpolation. This is what we'll fall
                    //   back to when enlarging, and imageSmoothingEnabled isn't supported.
                    //   In theory it's slower, but still pretty fast on my machine, and the
                    //   results look the same AFAICT.
                    // Is imageSmoothingEnabled supported? If so, we can let canvas do
                    // nearest-neighbor interpolation for us.

                    var smoothingProperty = getCanvasSmoothingProperty(ctx);

                    if (smoothingProperty || imgRes.x >= 256 && imgRes.y >= 256) {
                      // Use built-in scaling
                      // Turn off anti-aliasing if necessary
                      if (smoothingProperty) {
                        ctx[smoothingProperty] = imgRes.x >= 256 && imgRes.y
                            >= 256;
                      } // Don't necessarily draw with the full-size image; if we're
                      // downscaling, use the mipmapper to get a pre-downscaled image
                      // (see comments on Mipmapper class for why this matters).

                      mipmapper.getBySize(extent.x * 256, extent.y * 256,
                          function (mip) {
                            // It's possible that the image will go off the edge of the canvas--
                            // that's OK, the canvas should clip appropriately.
                            ctx.drawImage(mip, // Convert abs tile coords to rel tile coords, then *256 to convert
                                // to rel pixel coords
                                (topLeft.x - tilePoint.x) * 256,
                                (topLeft.y - tilePoint.y) * 256, // Always draw the whole thing and let canvas clip; so we can just
                                // convert from size in tile coords straight to pixels
                                extent.x * 256, extent.y * 256);
                          });
                    } else {
                      // Use manual nearest-neighbor interpolation
                      // Calculate the source image pixel coordinates that correspond with
                      // the top-left and bottom-right of this tile. (If the source image
                      // only partially overlaps the tile, we use max/min to limit the
                      // sourceStart/End to only reflect the overlapping portion.)
                      var sourceStart = {
                        x: Math.max(0,
                            Math.floor((tilePoint.x - topLeft.x) * imgRes.x)),
                        y: Math.max(0,
                            Math.floor((tilePoint.y - topLeft.y) * imgRes.y))
                      };
                      var sourceEnd = {
                        x: Math.min(w, Math.ceil(
                            (tilePoint.x + 1 - topLeft.x) * imgRes.x)),
                        y: Math.min(h,
                            Math.ceil((tilePoint.y + 1 - topLeft.y) * imgRes.y))
                      }; // The size, in dest pixels, that each source pixel should occupy.
                      // This might be greater or less than 1 (e.g. if x and y resolution
                      // are very different).

                      var pixelSize = {
                        x: 256 / imgRes.x,
                        y: 256 / imgRes.y
                      }; // For each pixel in the source image that overlaps the tile...

                      for (var row = sourceStart.y; row < sourceEnd.y; row++) {
                        for (var col = sourceStart.x; col < sourceEnd.x;
                            col++) {
                          // ...extract the pixel data...
                          var i = (row * w + col) * 4;
                          var r = imgData[i];
                          var g = imgData[i + 1];
                          var b = imgData[i + 2];
                          var a = imgData[i + 3];
                          ctx.fillStyle = "rgba(" + [r, g, b, a / 255].join(
                              ",") + ")"; // ...calculate the corresponding pixel coord in the dest image
                          // where it should be drawn...

                          var pixelPos = {
                            x: (col / imgRes.x + topLeft.x - tilePoint.x)
                                * 256,
                            y: (row / imgRes.y + topLeft.y - tilePoint.y)
                                * 256
                          }; // ...and draw a rectangle there.

                          ctx.fillRect(Math.round(pixelPos.x),
                              Math.round(pixelPos.y), // Looks crazy, but this is necessary to prevent rounding from
                              // causing overlap between this rect and its neighbors. The
                              // minuend is the location of the next pixel, while the
                              // subtrahend is the position of the current pixel (to turn an
                              // absolute coordinate to a width/height). Yes, I had to look
                              // up minuend and subtrahend.
                              Math.round(pixelPos.x + pixelSize.x)
                              - Math.round(pixelPos.x),
                              Math.round(pixelPos.y + pixelSize.y)
                              - Math.round(pixelPos.y));
                        }
                      }
                    }
                  } catch (e) {
                    error = e;
                  } finally {
                    done(error, canvas);
                  }
                });
                return canvas;
              };

              this.layerManager.addLayer(canvasTiles, "image", layerId, group);
            };

            methods.removeImage = function (layerId) {
              this.layerManager.removeLayer("image", layerId);
            };

            methods.clearImages = function () {
              this.layerManager.clearLayers("image");
            };

            methods.addMeasure = function (options) {
              // if a measureControl already exists, then remove it and
              //   replace with a new one
              methods.removeMeasure.call(this);
              this.measureControl = _leaflet2["default"].control.measure(options);
              this.addControl(this.measureControl);
            };

            methods.removeMeasure = function () {
              if (this.measureControl) {
                this.removeControl(this.measureControl);
                this.measureControl = null;
              }
            };

            methods.addSelect = function (ctGroup) {
              var _this8 = this;

              methods.removeSelect.call(this);
              this._selectButton = _leaflet2["default"].easyButton({
                states: [{
                  stateName: "select-inactive",
                  icon: "ion-qr-scanner",
                  title: "Make a selection",
                  onClick: function onClick(btn, map) {
                    btn.state("select-active");
                    _this8._locationFilter = new _leaflet2["default"].LocationFilter2();

                    if (ctGroup) {
                      var selectionHandle = new global.crosstalk.SelectionHandle(
                          ctGroup);
                      selectionHandle.on("change", function (e) {
                        if (e.sender !== selectionHandle) {
                          if (_this8._locationFilter) {
                            _this8._locationFilter.disable();

                            btn.state("select-inactive");
                          }
                        }
                      });

                      var handler = function handler(e) {
                        _this8.layerManager.brush(
                            _this8._locationFilter.getBounds(), {
                              sender: selectionHandle
                            });
                      };

                      _this8._locationFilter.on("enabled", handler);

                      _this8._locationFilter.on("change", handler);

                      _this8._locationFilter.on("disabled", function () {
                        selectionHandle.close();
                        _this8._locationFilter = null;
                      });
                    }

                    _this8._locationFilter.addTo(map);
                  }
                }, {
                  stateName: "select-active",
                  icon: "ion-close-round",
                  title: "Dismiss selection",
                  onClick: function onClick(btn, map) {
                    btn.state("select-inactive");

                    _this8._locationFilter.disable(); // If explicitly dismissed, clear the crosstalk selections

                    _this8.layerManager.unbrush();
                  }
                }]
              });

              this._selectButton.addTo(this);
            };

            methods.removeSelect = function () {
              if (this._locationFilter) {
                this._locationFilter.disable();
              }

              if (this._selectButton) {
                this.removeControl(this._selectButton);
                this._selectButton = null;
              }
            };

            methods.createMapPane = function (name, zIndex) {
              this.createPane(name);
              this.getPane(name).style.zIndex = zIndex;
            };

          }).call(this)
        }).call(this,
            typeof global !== "undefined" ? global : typeof self !== "undefined" ? self
                : typeof window !== "undefined" ? window : {})
      }, {
        "./cluster-layer-store": 1,
        "./crs_utils": 3,
        "./dataframe": 4,
        "./global/htmlwidgets": 8,
        "./global/jquery": 9,
        "./global/leaflet": 10,
        "./global/shiny": 12,
        "./mipmapper": 16,
        "./util": 17
      }],
      16: [function (require, module, exports) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }

        function _defineProperties(target, props) {
          for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) {
              descriptor.writable = true;
            }
            Object.defineProperty(target, descriptor.key, descriptor);
          }
        }

        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps) {
            _defineProperties(Constructor.prototype, protoProps);
          }
          if (staticProps) {
            _defineProperties(Constructor, staticProps);
          }
          return Constructor;
        }

// This class simulates a mipmap, which shrinks images by powers of two. This
// stepwise reduction results in "pixel-perfect downscaling" (where every
// pixel of the original image has some contribution to the downscaled image)
// as opposed to a single-step downscaling which will discard a lot of data
// (and with sparse images at small scales can give very surprising results).
        var Mipmapper = /*#__PURE__*/function () {
          function Mipmapper(img) {
            _classCallCheck(this, Mipmapper);

            this._layers = [img];
          } // The various functions on this class take a callback function BUT MAY OR MAY
          // NOT actually behave asynchronously.

          _createClass(Mipmapper, [{
            key: "getBySize",
            value: function getBySize(desiredWidth, desiredHeight, callback) {
              var _this = this;

              var i = 0;
              var lastImg = this._layers[0];

              var testNext = function testNext() {
                _this.getByIndex(i, function (img) {
                  // If current image is invalid (i.e. too small to be rendered) or
                  // it's smaller than what we wanted, return the last known good image.
                  if (!img || img.width < desiredWidth || img.height
                      < desiredHeight) {
                    callback(lastImg);

                  } else {
                    lastImg = img;
                    i++;
                    testNext();

                  }
                });
              };

              testNext();
            }
          }, {
            key: "getByIndex",
            value: function getByIndex(i, callback) {
              var _this2 = this;

              if (this._layers[i]) {
                callback(this._layers[i]);
                return;
              }

              this.getByIndex(i - 1, function (prevImg) {
                if (!prevImg) {
                  // prevImg could not be calculated (too small, possibly)
                  callback(null);
                  return;
                }

                if (prevImg.width < 2 || prevImg.height < 2) {
                  // Can't reduce this image any further
                  callback(null);
                  return;
                } // If reduce ever becomes truly asynchronous, we should stuff a promise or
                // something into this._layers[i] before calling this.reduce(), to prevent
                // redundant reduce operations from happening.

                _this2.reduce(prevImg, function (reducedImg) {
                  _this2._layers[i] = reducedImg;
                  callback(reducedImg);

                });
              });
            }
          }, {
            key: "reduce",
            value: function reduce(img, callback) {
              var imgDataCanvas = document.createElement("canvas");
              imgDataCanvas.width = Math.ceil(img.width / 2);
              imgDataCanvas.height = Math.ceil(img.height / 2);
              imgDataCanvas.style.display = "none";
              document.body.appendChild(imgDataCanvas);

              try {
                var imgDataCtx = imgDataCanvas.getContext("2d");
                imgDataCtx.drawImage(img, 0, 0, img.width / 2, img.height / 2);
                callback(imgDataCanvas);
              } finally {
                document.body.removeChild(imgDataCanvas);
              }
            }
          }]);

          return Mipmapper;
        }();

        exports["default"] = Mipmapper;

      }, {}],
      17: [function (require, module, exports) {
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });
        exports.log = log;
        exports.recycle = recycle;
        exports.asArray = asArray;

        function log(message) {
          /* eslint-disable no-console */
          if (console && console.log) {
            console.log(message);
          }
          /* eslint-enable no-console */
        }

        function recycle(values, length, inPlace) {
          if (length === 0 && !inPlace) {
            return [];
          }

          if (!(values instanceof Array)) {
            if (inPlace) {
              throw new Error("Can't do in-place recycling of a non-Array value");
            }

            values = [values];
          }

          if (typeof length === "undefined") {
            length = values.length;
          }
          var dest = inPlace ? values : [];
          var origLength = values.length;

          while (dest.length < length) {
            dest.push(values[dest.length % origLength]);
          }

          if (dest.length > length) {
            dest.splice(length, dest.length - length);
          }

          return dest;
        }

        function asArray(value) {
          if (value instanceof Array) {
            return value;
          } else {
            return [value];
          }
        }

      }, {}]
    }, {}, [13]);
  </script>

</head>
<body style="background-color: white;">
<div id="htmlwidget_container">
  <div class="leaflet html-widget" id="htmlwidget-df32f86ba55fc736e00a"
       style="width:100%;height:400px;">

  </div>
</div>
<script data-for="htmlwidget-df32f86ba55fc736e00a" type="application/json">{
  "x": {
    "options": {
      "crs": {
        "crsClass": "L.CRS.EPSG3857",
        "code": null,
        "proj4def": null,
        "projectedBounds": null,
        "options": {}
      }
    },
    "calls": [
      {
        "method": "addTiles",
        "args": [
          "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          null,
          null,
          {
            "minZoom": 0,
            "maxZoom": 18,
            "tileSize": 256,
            "subdomains": "abc",
            "errorTileUrl": "",
            "tms": false,
            "noWrap": false,
            "zoomOffset": 0,
            "zoomReverse": false,
            "opacity": 1,
            "zIndex": 1,
            "detectRetina": false,
            "attribution": "&copy; <a href=\"https://openstreetmap.org\">OpenStreetMap<\/a> contributors, <a href=\"https://creativecommons.org/licenses/by-sa/2.0/\">CC-BY-SA<\/a>"
          }
        ]
      },
      {
        "method": "addMarkers",
        "args": [
          [
            34.416929,
            37.233333,
            21.3679,
            73.640556,
            46.235,
            34.9247532
          ],
          [
            -119.845991,
            -115.808333,
            -157.9771,
            54.58,
            6.045,
            135.7960274
          ],
          null,
          null,
          null,
          {
            "interactive": true,
            "draggable": false,
            "keyboard": true,
            "title": "",
            "alt": "",
            "zIndexOffset": 0,
            "opacity": 1,
            "riseOnHover": false,
            "riseOffset": 250
          },
          [
            "<div class='leaflet-popup-scrolled' style='max-width:600px;max-height:300px'><b> <a href= https://en.wikipedia.org/wiki/University_of_California,_Santa_Barbara  target=\"_blank\"> <h2 align=\"center\"><strong> UCSB <\/strong><\/h2><\/a><br> <\/b> A great university located along the California coast! <br><br><center><img src=\" https://web.physics.ucsb.edu/~Women/images/ucsb-big.jpg \" height=\"150px\" width=\"200px\" border=\"8\"><\/center><br> <\/div>",
            "<div class='leaflet-popup-scrolled' style='max-width:600px;max-height:300px'><b> <a href= https://en.wikipedia.org/wiki/Area_51  target=\"_blank\"> <h2 align=\"center\"><strong> Area 51 <\/strong><\/h2><\/a><br> <\/b> A highly classified<a0>United States Air Force<a0>(USAF) facility within the<a0>Nevada Test and Training Range. <br><br><center><img src=\" https://upload.wikimedia.org/wikipedia/commons/8/87/Wfm_area_51_landsat_geocover_2000.jpg \" height=\"150px\" width=\"200px\" border=\"8\"><\/center><br> <\/div>",
            "<div class='leaflet-popup-scrolled' style='max-width:600px;max-height:300px'><b> <a href= https://en.wikipedia.org/wiki/Pearl_Harbor  target=\"_blank\"> <h2 align=\"center\"><strong> Pearl Harbor <\/strong><\/h2><\/a><br> <\/b> An American lagoon harbor on the island of Oahu, Hawaii, west of Honolulu. <br><br><center><img src=\" https://upload.wikimedia.org/wikipedia/commons/0/00/Ford_Island_aerial_photo_RIMPAC_1986.JPEG \" height=\"150px\" width=\"200px\" border=\"8\"><\/center><br> <\/div>",
            "<div class='leaflet-popup-scrolled' style='max-width:600px;max-height:300px'><b> <a href= https://en.wikipedia.org/wiki/Mityushikha_Bay  target=\"_blank\"> <h2 align=\"center\"><strong> Mityushikha Bay <\/strong><\/h2><\/a><br> <\/b> A bay on Severny Island in Novaya Zemlya, Russia where nuclear tests were conducted in 1961. <br><br><center><img src=\" https://upload.wikimedia.org/wikipedia/commons/1/1f/Relief_Map_of_Novaya_Zemlya.png \" height=\"150px\" width=\"200px\" border=\"8\"><\/center><br> <\/div>",
            "<div class='leaflet-popup-scrolled' style='max-width:600px;max-height:300px'><b> <a href= https://en.wikipedia.org/wiki/Large_Hadron_Collider  target=\"_blank\"> <h2 align=\"center\"><strong> Large Hadron Collider <\/strong><\/h2><\/a><br> <\/b> The world's largest and highest-energy particle collider. <br><br><center><img src=\" https://upload.wikimedia.org/wikipedia/commons/0/06/LHC_quadrupole_magnets.jpg \" height=\"150px\" width=\"200px\" border=\"8\"><\/center><br> <\/div>",
            "<div class='leaflet-popup-scrolled' style='max-width:600px;max-height:300px'><b> <a href= https://en.wikipedia.org/wiki/Kyoto_Animation  target=\"_blank\"> <h2 align=\"center\"><strong> Kyoto Animation Studio 2 <\/strong><\/h2><\/a><br> <\/b> The head office of a Japanese animation studio and light novel publisher. <br><br><center><img src=\" https://upload.wikimedia.org/wikipedia/commons/b/b7/Kyoto_Animation_head_office_20101010.jpg \" height=\"150px\" width=\"200px\" border=\"8\"><\/center><br> <\/div>"
          ],
          null,
          null,
          null,
          null,
          {
            "interactive": false,
            "permanent": false,
            "direction": "auto",
            "opacity": 1,
            "offset": [
              0,
              0
            ],
            "textsize": "10px",
            "textOnly": false,
            "className": "",
            "sticky": true
          },
          null
        ]
      }
    ],
    "limits": {
      "lat": [
        21.3679,
        73.640556
      ],
      "lng": [
        -157.9771,
        135.7960274
      ]
    }
  },
  "evals": [],
  "jsHooks": []
}</script>
<script data-for="htmlwidget-df32f86ba55fc736e00a" type="application/htmlwidget-sizing">
  {
    "viewer": {
      "width": "100%",
      "height": 400,
      "padding": 0,
      "fill": true
    },
    "browser": {
      "width": "100%",
      "height": 400,
      "padding": 0,
      "fill": true
    }
  }




</script>
</body>
</html>
